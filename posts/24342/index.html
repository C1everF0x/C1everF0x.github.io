<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"><title>数据结构笔记（桂电教材版本） | C1everF0x的博客</title><meta name="author" content="C1everF0x,Oui0jr@163.com"><meta name="copyright" content="C1everF0x"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="ffffff"><meta name="description" content="写在前面 这个课是以前从来没接触过的东西，而且一直学 web，太久没接触 c 语言了，第一节课看到 for 循环甚至有点陌生，学得有点吃力，所以必须整点笔记，记下相关概念、知识点和平时学习过程中的问题和思考，期末复习用 2022.1.23 没想到我这笔记还能留到考研用，属于是未雨绸缪了  第一章 绪论 数据结构研究：数据的逻辑结构（数据内部之间的构成方法）、数据的物理储存（数据在内存里面怎么存的">
<meta property="og:type" content="article">
<meta property="og:title" content="数据结构笔记（桂电教材版本）">
<meta property="og:url" content="http://c1everf0x.top/posts/24342/index.html">
<meta property="og:site_name" content="C1everF0x的博客">
<meta property="og:description" content="写在前面 这个课是以前从来没接触过的东西，而且一直学 web，太久没接触 c 语言了，第一节课看到 for 循环甚至有点陌生，学得有点吃力，所以必须整点笔记，记下相关概念、知识点和平时学习过程中的问题和思考，期末复习用 2022.1.23 没想到我这笔记还能留到考研用，属于是未雨绸缪了  第一章 绪论 数据结构研究：数据的逻辑结构（数据内部之间的构成方法）、数据的物理储存（数据在内存里面怎么存的">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/10.jpg">
<meta property="article:published_time" content="2020-09-21T21:06:20.000Z">
<meta property="article:modified_time" content="2023-02-13T07:17:14.696Z">
<meta property="article:author" content="C1everF0x">
<meta property="article:tag" content="数据结构">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/10.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="http://c1everf0x.top/posts/24342/"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web&amp;display=swap" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"/search.xml","preload":true,"languages":{"hits_empty":"找不到您查询的内容：${query}"}},
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlighjs","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: true,
    post: true
  },
  runtime: '',
  date_suffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  source: {
    justifiedGallery: {
      js: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.js',
      css: 'https://cdn.jsdelivr.net/npm/flickr-justified-gallery/dist/fjGallery.min.css'
    }
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  }
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: '数据结构笔记（桂电教材版本）',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2023-02-13 07:17:14'
}</script><noscript><style type="text/css">
  #nav {
    opacity: 1
  }
  .justified-gallery img {
    opacity: 1
  }

  #recent-posts time,
  #post-meta time {
    display: inline !important
  }
</style></noscript><script>(win=>{
    win.saveToLocal = {
      set: function setWithExpiry(key, value, ttl) {
        if (ttl === 0) return
        const now = new Date()
        const expiryDay = ttl * 86400000
        const item = {
          value: value,
          expiry: now.getTime() + expiryDay,
        }
        localStorage.setItem(key, JSON.stringify(item))
      },

      get: function getWithExpiry(key) {
        const itemStr = localStorage.getItem(key)

        if (!itemStr) {
          return undefined
        }
        const item = JSON.parse(itemStr)
        const now = new Date()

        if (now.getTime() > item.expiry) {
          localStorage.removeItem(key)
          return undefined
        }
        return item.value
      }
    }
  
    win.getScript = url => new Promise((resolve, reject) => {
      const script = document.createElement('script')
      script.src = url
      script.async = true
      script.onerror = reject
      script.onload = script.onreadystatechange = function() {
        const loadState = this.readyState
        if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
        script.onload = script.onreadystatechange = null
        resolve()
      }
      document.head.appendChild(script)
    })
  
      win.activateDarkMode = function () {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = function () {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', 'ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
          const isDarkMode = window.matchMedia('(prefers-color-scheme: dark)').matches
          const isLightMode = window.matchMedia('(prefers-color-scheme: light)').matches
          const isNotSpecified = window.matchMedia('(prefers-color-scheme: no-preference)').matches
          const hasNoSupport = !isDarkMode && !isLightMode && !isNotSpecified

          if (t === undefined) {
            if (isLightMode) activateLightMode()
            else if (isDarkMode) activateDarkMode()
            else if (isNotSpecified || hasNoSupport) {
              const now = new Date()
              const hour = now.getHours()
              const isNight = hour <= 6 || hour >= 18
              isNight ? activateDarkMode() : activateLightMode()
            }
            window.matchMedia('(prefers-color-scheme: dark)').addListener(function (e) {
              if (saveToLocal.get('theme') === undefined) {
                e.matches ? activateDarkMode() : activateLightMode()
              }
            })
          } else if (t === 'light') activateLightMode()
          else activateDarkMode()
        
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
    const detectApple = () => {
      if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
        document.documentElement.classList.add('apple')
      }
    }
    detectApple()
    })(window)</script><link rel="stylesheet" href="/css/bg.css"><!-- hexo injector head_end start --><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/Zfour/Butterfly-double-row-display@1.00/cardlistpost.min.css"/>
<style>#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags:before {content:"\A";
  white-space: pre;}#recent-posts > .recent-post-item >.recent-post-info > .article-meta-wrap > .tags > .article-meta__separator{display:none}</style>
<link rel="stylesheet" href="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.css" /><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.css" media="print" onload="this.media='all'"><link rel="stylesheet" href="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiperstyle.css" media="print" onload="this.media='all'"><!-- hexo injector head_end end --><meta name="generator" content="Hexo 6.3.0"></head><body><div id="loading-box"><style>css-doodle {--color: @p(#51eaea, #fffde1, #ff9d76, #FB3569);--rule: (:doodle {@grid: 30x1 / 18vmin;--deg: @p(-180deg, 180deg);}:container {perspective: 30vmin;}:after, :before {content: '';background: var(--color); @place-cell: @r(100%) @r(100%); @size: @r(6px); @shape: heart;} @place-cell: center; @size: 100%;box-shadow: @m2(0 0 50px var(--color));background: @m100(radial-gradient(var(--color) 50%, transparent 0)@r(-20%, 120%) @r(-20%, 100%) / 1px 1px no-repeat); will-change: transform, opacity; animation: scale-up 12s linear infinite; animation-delay: calc(-12s / @I * @i); @keyframes scale-up { 0%, 95.01%, 100% {transform: translateZ(0) rotate(0);opacity: 0;}10% {opacity: 1;}95% {transform: translateZ(35vmin) rotateZ(@var(--deg));}})}</style><css-doodle use="var(--rule)"></css-doodle><script async="async" src="https://npm.elemecdn.com/css-doodle@0.15.3/css-doodle.min.js"></script></div><script>const preloader = {
  endLoading: () => {
    document.body.style.overflow = 'auto';
    document.getElementById('loading-box').classList.add("loaded")
  },
  initLoading: () => {
    document.body.style.overflow = '';
    document.getElementById('loading-box').classList.remove("loaded")

  }
}
window.addEventListener('load',()=> { preloader.endLoading() })

if (false) {
  document.addEventListener('pjax:send', () => { preloader.initLoading() })
  document.addEventListener('pjax:complete', () => { preloader.endLoading() })
}</script><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="http://q1.qlogo.cn/g?b=qq&amp;nk=1160118161&amp;s=640" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><hr/><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Misc</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image: url('https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/10.jpg')"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">C1everF0x的博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i><span> 搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i><span> 主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i><span> 文章</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i><span> 标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i><span> 分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);"><i class="fa-fw fas fa-list"></i><span> Misc</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i><span> Music</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-video"></i><span> Movie</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i><span> 友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-heart"></i><span> 关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">数据结构笔记（桂电教材版本）</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-09-21T21:06:20.000Z" title="发表于 2020-09-21 21:06:20">2020-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2023-02-13T07:17:14.696Z" title="更新于 2023-02-13 07:17:14">2023-02-13</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/">学习笔记</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="数据结构笔记（桂电教材版本）"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><blockquote>
<p>写在前面</p>
<p>这个课是以前从来没接触过的东西，而且一直学 web，太久没接触 c 语言了，第一节课看到 for 循环甚至有点陌生，学得有点吃力，所以必须整点笔记，记下相关概念、知识点和平时学习过程中的问题和思考，期末复习用</p>
<p>2022.1.23</p>
<p>没想到我这笔记还能留到考研用，属于是未雨绸缪了</p>
</blockquote>
<h1 id="第一章-绪论"><a href="#第一章-绪论" class="headerlink" title="第一章 绪论"></a>第一章 绪论</h1><ul>
<li>数据结构研究：数据的逻辑结构（数据内部之间的构成方法）、数据的物理储存（数据在内存里面怎么存的）、数据的操作实现（用什么语言写，用什么算法实现）三方面的问题</li>
</ul>
<h2 id="抽象数据类型（Abstract-Data-Type，ADT）"><a href="#抽象数据类型（Abstract-Data-Type，ADT）" class="headerlink" title="抽象数据类型（Abstract Data Type，ADT）"></a>抽象数据类型（Abstract Data Type，ADT）</h2><p>一个数学模型以及定义在该模型上的一组操作，强调对数据类型的抽象，不讲究具体实现</p>
<p>作用：目的在于隐藏运算实现的细节和内部数据结构，同时向用户提供该数据类型的接口</p>
<h2 id="应用程序编程接口（Application-Program-Interface，API）"><a href="#应用程序编程接口（Application-Program-Interface，API）" class="headerlink" title="应用程序编程接口（Application Program Interface，API）"></a>应用程序编程接口（Application Program Interface，API）</h2><p>把实现和使用分离，把编程模块化，函数封装成的库就是一个典型的API接口，只管用，一般不用管这个库是怎么写的，这也是面向对象编程的一个重要思维</p>
<h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="行话"><a href="#行话" class="headerlink" title="行话"></a>行话</h3><ul>
<li>数据：信息的载体，能够被计算机程序处理的一些符号（字符、数字、声音和图像等等）</li>
<li>数据元素&#x2F;结点：组成数据的基本单位</li>
<li>数据项：&#x3D;&#x3D;是数据的最小单位&#x3D;&#x3D;，是数据元素的组成单位，比它还小</li>
<li>数据结构：存在相互关系的数据元素的集合，开发者会根据这种数据结构设计相应的算法，确保运算以后的新结构依旧保持原来的结构类型</li>
<li>数据对象：是必须由软件理解的复合信息表示，跟上面四个东西没有很强的逻辑关系，数据对象描述包括了其所有的属性，只用来封装数据，不对数据进行操作</li>
</ul>
<hr>
<blockquote>
<p>整点自己的理解</p>
</blockquote>
<p>假如有两张表，一个是课程表，一个是憨憨弱口令表，那么这两张表就是&#x3D;&#x3D;数据&#x3D;&#x3D;</p>
<table>
<thead>
<tr>
<th>课程代号</th>
<th>课程名字</th>
<th>授课老师</th>
</tr>
</thead>
<tbody><tr>
<td>123456789</td>
<td>数据结构</td>
<td>张瑞霞</td>
</tr>
<tr>
<td>987654321</td>
<td>网络渗透测试</td>
<td>xx</td>
</tr>
<tr>
<td>135792468</td>
<td>信息安全数学基础</td>
<td>xxx</td>
</tr>
</tbody></table>
<table>
<thead>
<tr>
<th>id</th>
<th>username</th>
<th>password</th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>admin</td>
<td>123456</td>
</tr>
<tr>
<td>2</td>
<td>root</td>
<td>root</td>
</tr>
<tr>
<td>3</td>
<td>admin888</td>
<td>888888</td>
</tr>
</tbody></table>
<p>每一张表的每一行数据就是&#x3D;&#x3D;数据元素&#x3D;&#x3D;</p>
<p>每一行里面的列值就是&#x3D;&#x3D;数据项&#x3D;&#x3D;，比如课程名字、password</p>
<p>几行几列，行的值最大能存储多少字节，能不能为空，列的数据类型是什么，表头是什么，这些是开发设计的&#x3D;&#x3D;数据结构&#x3D;&#x3D;</p>
<p>单独的一张表就是叫&#x3D;&#x3D;数据对象&#x3D;&#x3D;，比如憨憨弱口令表就是一个数据对象，课程表也是一个数据对象</p>
<hr>
<ul>
<li>前驱：一个结点前面的结点叫前驱</li>
<li>后继：一个结点后面的结点叫后继</li>
</ul>
<blockquote>
<p>所以很明显开始的结点没有前驱，结束的结点没有后继，我当时听课还想老半天</p>
</blockquote>
<h3 id="数据的逻辑结构"><a href="#数据的逻辑结构" class="headerlink" title="数据的逻辑结构"></a>数据的逻辑结构</h3><p>就是数据元素之间的逻辑关系，常见以下四种：</p>
<ul>
<li>集合：结点之间没有关系</li>
<li>线性结构：结点之间一对一联系起来，&#x3D;&#x3D;一根绳上的蚂蚱&#x3D;&#x3D;</li>
<li>树形结构：结点之间一对多的关系，&#x3D;&#x3D;叫树形结构的原因也是因为和现实生活中的树的树枝很像吧&#x3D;&#x3D;</li>
<li>图形结构：结点之间多对多的关系</li>
</ul>
<h3 id="数据的存储结构"><a href="#数据的存储结构" class="headerlink" title="数据的存储结构"></a>数据的存储结构</h3><ul>
<li>顺序存储结构：拿计算机里一组连续的存储单元来存放数据，用内存地址来体现逻辑关系，可以理解为逻辑关系和物理位置是一样的，都排好队。对应之后学习的&#x3D;&#x3D;顺序表&#x3D;&#x3D;</li>
<li>链式存储结构：数据元素存放位置由编译器随机分配，数据元素之间的逻辑关系就不能通过物理位置来体现，需要用指针来把分散的结点串起来。对应之后学习的&#x3D;&#x3D;链表&#x3D;&#x3D;</li>
<li>索引存储结构：在存储结点的时候同时增加一个索引表，表中的每一项作为索引项，需要包含一个结点的关键码（准确识别）和存储位置</li>
<li>散列储存结构：将结点的关键字作为散列函数的输入，散列函数输出的是结点的存储位置</li>
</ul>
<h3 id="数据的操作"><a href="#数据的操作" class="headerlink" title="数据的操作"></a>数据的操作</h3><p>优秀的算法</p>
<h2 id="算法复杂度"><a href="#算法复杂度" class="headerlink" title="算法复杂度"></a>算法复杂度</h2><ul>
<li>分时间复杂度和空间复杂度</li>
</ul>
<h3 id="时间复杂度"><a href="#时间复杂度" class="headerlink" title="时间复杂度"></a>时间复杂度</h3><p>算法的基本操作重复执行的次数用<code>T(n)</code>表示，再来一个辅助函数<code>f(n)</code>，当 n 趋于正无穷的时候，<code>T(n)</code>&#x2F;<code>f(n)</code>为一个常数，即辅助函数是执行次数的同数量级函数时，时间复杂度就是<code>O(f(n))</code></p>
<h3 id="分析方法"><a href="#分析方法" class="headerlink" title="分析方法"></a>分析方法</h3><ol>
<li><p>&#x3D;&#x3D;只关注循环执行次数最多的那段代码&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;时间复杂度是一种变化的趋势，当 n 趋于无穷大时，通常忽略掉常量、低阶和系数的影响，只记录大的高阶量&#x3D;&#x3D;</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f0x</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum += i;	<span class="comment">//求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 这段代码我们就只用看 sum+=1 循环了 n 次，所以时间复杂度就是O(n)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>加法法则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f0x</span><span class="params">(<span class="type">int</span> m, <span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> sum_1 = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum_1 += i;	<span class="comment">//求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> sum_2 = <span class="number">0</span>;</span><br><span class="line">    i = i ^ i;	<span class="comment">//把i置零</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; m;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        sum_2 += i;	<span class="comment">//求和</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum_1 + sum_2;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//无法评估 m 和 n 同时趋于正无穷时哪个大，所以用加法法则 T1(m)+ T2(n) = O(f(m)) + O(f(n))</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>乘法法则</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">f0x</span><span class="params">(<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;	<span class="comment">//计数器</span></span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> j = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; n;i++)	<span class="comment">//执行 n+1 次</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)	<span class="comment">//执行 n(n+1) 次</span></span><br><span class="line">            flag++;	<span class="comment">//执行 n^2次</span></span><br><span class="line">    <span class="keyword">return</span> flag;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//一组嵌套的 for 循环，T(n)=2n^2+2n+1，取同数量级 n^2作为时间复杂度，即O(n^2)</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="举例"><a href="#举例" class="headerlink" title="举例"></a>举例</h3><ul>
<li><p>线性级数O(n)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(flag = <span class="number">0</span>,i = <span class="number">0</span>;i &lt; n;i++)	<span class="comment">// n+1 次</span></span><br><span class="line">    flag++;	<span class="comment">//n 次</span></span><br><span class="line"><span class="comment">// T(n)=2n+1</span></span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(flag = <span class="number">0</span>,i = <span class="number">1</span>;i &lt;= n;i = i * <span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt;= i;j++)</span><br><span class="line">        flag++;</span><br></pre></td></tr></table></figure>

<p>第三行的执行次数是一个等比数列的和，等比数列为 1+2+4+2^(log<del>2</del>^n^+1)+… ，利用高等数学的知识可以知道时间复杂度为 O(n)</p>
</li>
<li><p>对数级数O(log<del>x</del>^n^)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(flag = <span class="number">0</span>,i = <span class="number">1</span>;i &lt;= n;i = i * x)</span><br><span class="line">    flag++;</span><br><span class="line"><span class="comment">// 当 n=1时，循环执行1次,n=x^2时，循环执行2次，n=x^3时，循环执行3次，数学规律为循环执行logxn次</span></span><br><span class="line"><span class="comment">// T(n)=logxn</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>平方级数O(n^2^)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(flag = <span class="number">0</span>,i = <span class="number">0</span>;i &lt; n;i++)	<span class="comment">// n+1 次</span></span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">0</span>;j &lt; n;j++)	<span class="comment">// n 次</span></span><br><span class="line">        flag++;	<span class="comment">// n(n+1)次</span></span><br><span class="line"><span class="comment">// T(n)=2n^2+2n+1</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>二阶级数O(nlog<del>x</del>^n^)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(flag = <span class="number">0</span>,i =<span class="number">0</span>;i &lt; n;i++)</span><br><span class="line">    <span class="keyword">for</span>(j = <span class="number">1</span>;j &lt;= n;j = j * x)</span><br><span class="line">        flag++;</span><br><span class="line"><span class="comment">// 第一行执行 n+1 次，第二行执行 logxn 次，第三行执行 nlogxn 次</span></span><br><span class="line"><span class="comment">// T(n)= n+1+logxn+nlogxn</span></span><br></pre></td></tr></table></figure>

<ul>
<li>二阶级数的内外层循环调换顺序结果也是一样</li>
</ul>
</li>
</ul>
<blockquote>
<p>第一章结束，概念比较多，时间复杂度比较重要</p>
<p>去csdn看到的比较好的文章</p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/weixin_39596963/article/details/80987779?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160099621219724835865369%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160099621219724835865369&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-80987779.first_rank_v2_rank_v25&amp;utm_term=%E6%B8%90%E8%BF%9B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/weixin_39596963/article/details/80987779?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160099621219724835865369%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160099621219724835865369&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~first_rank_v2~rank_v25-1-80987779.first_rank_v2_rank_v25&amp;utm_term=%E6%B8%90%E8%BF%9B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1018.2118.3001.4187</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/qq_41523096/article/details/82142747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160099621219724835865369%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160099621219724835865369&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-82142747.first_rank_v2_rank_v25&amp;utm_term=%E6%B8%90%E8%BF%9B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1018.2118.3001.4187">https://blog.csdn.net/qq_41523096/article/details/82142747?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522160099621219724835865369%2522%252C%2522scm%2522%253A%252220140713.130102334..%2522%257D&amp;request_id=160099621219724835865369&amp;biz_id=0&amp;utm_medium=distribute.pc_search_result.none-task-blog-2~all~top_click~default-3-82142747.first_rank_v2_rank_v25&amp;utm_term=%E6%B8%90%E8%BF%9B%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6&amp;spm=1018.2118.3001.4187</a></p>
</blockquote>
<hr>
<h1 id="第二章-线性表"><a href="#第二章-线性表" class="headerlink" title="第二章 线性表"></a>第二章 线性表</h1><ul>
<li>线性表是由 n(n&gt;&#x3D;0) 个性质相同的数据元素组成的&#x3D;&#x3D;有限序列&#x3D;&#x3D;</li>
<li>同一线性表中的元素类型相同</li>
<li>主要操作有：创建空线性表、判断线性表是否为空、插入、删除和查找等基本操作</li>
</ul>
<h2 id="顺序表"><a href="#顺序表" class="headerlink" title="顺序表"></a>顺序表</h2><ul>
<li>顺序表用一组&#x3D;&#x3D;地址连续的存储单元&#x3D;&#x3D;依次存储线性表中的各元素，通过位置来表示数据元素之间的逻辑关系，数据元素的逻辑关系和物理关系一样</li>
</ul>
<p><img src="https://raw.githubusercontent.com/C1everF0x/Images/master/20200929162306.png" alt="链表和顺序表"></p>
<h3 id="顺序表类型定义"><a href="#顺序表类型定义" class="headerlink" title="顺序表类型定义"></a>顺序表类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;	<span class="comment">//给 int 换名字</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">List</span>	//定义顺序表类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Max;	<span class="comment">//最大元素个数</span></span><br><span class="line">    <span class="type">int</span> n;	<span class="comment">//实际元素个数</span></span><br><span class="line">    DataType *elem;	<span class="comment">//首地址</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">List</span> *<span class="title">SeqList</span>;</span>	<span class="comment">//把顺序表类型名字换成 *SeqList</span></span><br></pre></td></tr></table></figure>

<h3 id="顺序表建立和判空"><a href="#顺序表建立和判空" class="headerlink" title="顺序表建立和判空"></a>顺序表建立和判空</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">SeqList <span class="title function_">SetNullList_Seq</span><span class="params">(<span class="type">int</span> m)</span>	<span class="comment">//创建空顺序表，m为顺序表最大值</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqList slist = (SeqList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> List));	<span class="comment">//申请结构体List空间</span></span><br><span class="line">    <span class="keyword">if</span>(slist != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;elem = (DataType*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DataType)*m);	<span class="comment">//申请顺序表空间，大小为m个DataType空间</span></span><br><span class="line">        <span class="keyword">if</span>(slist-&gt;elem)</span><br><span class="line">        &#123;</span><br><span class="line">            slist-&gt;Max = m;	<span class="comment">//顺序表最大值</span></span><br><span class="line">        	slist-&gt;n = <span class="number">0</span>;	<span class="comment">//顺序表长度赋值为0</span></span><br><span class="line">            <span class="keyword">return</span>(slist);	<span class="comment">//返回slist首地址</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="built_in">free</span>(slist);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;out of space!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsNullList_seq</span><span class="params">(SeqList slist)</span>	<span class="comment">//判断顺序表是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(slist-&gt;n == <span class="number">0</span>);	<span class="comment">//顺序表长度为0则是空的，如果为空 return(1)，如果不为空 return(0)</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表插入元素"><a href="#顺序表插入元素" class="headerlink" title="顺序表插入元素"></a>顺序表插入元素</h3><ol>
<li>移动结点</li>
<li>插入结点</li>
<li>&#x3D;&#x3D;增加表长&#x3D;&#x3D;</li>
<li>检查表空间是否已满</li>
<li>检查插入位置有效性</li>
<li>&#x3D;&#x3D;从最后一个结点开始向后移动&#x3D;&#x3D;</li>
<li>平均时间复杂度是 O(n)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InsertPre_seq</span><span class="params">(SeqList slist, <span class="type">int</span> p, DataType x)</span>	<span class="comment">//在表slist的 p 位置之前插入 x，成功返回1，否则返回0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="keyword">if</span>(slist-&gt;n &gt;= slist-&gt;Max)	<span class="comment">//检查表空间是否已满</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;overflow&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt; slist-&gt;n)	<span class="comment">//检查插入位置有效性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not exist!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(q = slist-&gt;n - <span class="number">1</span>; q &gt;= p; q--)	<span class="comment">//插入位置以及之后的元素后移</span></span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;elem[q+<span class="number">1</span>] = slist-&gt;elem[q];</span><br><span class="line">    &#125;</span><br><span class="line">    slist-&gt;elem[p] = x;	<span class="comment">//插入 x 元素</span></span><br><span class="line">    slist-&gt;n = slist-&gt;n+<span class="number">1</span>;	<span class="comment">//表长+1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表删除"><a href="#顺序表删除" class="headerlink" title="顺序表删除"></a>顺序表删除</h3><ol>
<li>移动结点</li>
<li>&#x3D;&#x3D;减少表长&#x3D;&#x3D;</li>
<li>检查删除位置有效性</li>
<li>&#x3D;&#x3D;从删除位置的下一个元素开始移动&#x3D;&#x3D;</li>
<li>平均时间复杂度是O(n)</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">Delindex_seq</span><span class="params">(SeqList slist,<span class="type">int</span> p)</span>	<span class="comment">//删除下标为 p 的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> q;</span><br><span class="line">    <span class="keyword">if</span>(p &lt; <span class="number">0</span> || p &gt;= slist-&gt;n)	<span class="comment">//检查删除位置有效性</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Not exist\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(q = p; q &lt; slist-&gt;n<span class="number">-1</span>; q++)	<span class="comment">//p位置之后的元素向前移动</span></span><br><span class="line">    &#123;</span><br><span class="line">        slist-&gt;elem[q] = slist-&gt;elem[q+<span class="number">1</span>];</span><br><span class="line">        slist-&gt;n = slist-&gt;n<span class="number">-1</span>;	<span class="comment">//表长-1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里老师出了一个思考题，如何删除顺序表中所有值为 x 的元素</p>
<p>思路：把不等于 x 的元素提出来重新放到一个新数组里，建立flag变量来记录表长</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">deleteX_seq</span><span class="params">(SeqList slist,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;	<span class="comment">//循环变量</span></span><br><span class="line">    <span class="type">int</span> flag = <span class="number">0</span>;	<span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; slist-&gt;n; i++)	<span class="comment">//遍历顺序表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(slist-&gt;elem[i] != x)</span><br><span class="line">        &#123;</span><br><span class="line">            slist-&gt;elem[flag] = slist-&gt;elem[i];	<span class="comment">//把值不是 x 的元素放到新数组里</span></span><br><span class="line">            flag++;	<span class="comment">//用来记录新的表长</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    slist-&gt;n = flag;	<span class="comment">//更新新表长</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="顺序表查找定位"><a href="#顺序表查找定位" class="headerlink" title="顺序表查找定位"></a>顺序表查找定位</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">LocateIndex_seq</span><span class="params">(SeqList slist, <span class="type">int</span> x)</span>	<span class="comment">//遍历顺序表查找值为x的元素，返回其下标</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;	<span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i &lt; slist-&gt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(slist-&gt;elem[i] == x)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;	<span class="comment">//查找失败返回-1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>已经排好序的顺序表可以采用二分法查找，详见书P28页</p>
</blockquote>
<h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><ul>
<li>链表用一组&#x3D;&#x3D;任意的存储单元&#x3D;&#x3D;存储线性表中各元素，通过指针来表示数据元素之间的逻辑关系，数据元素的逻辑关系和物理关系不一样</li>
<li>&#x3D;&#x3D;单链表的一个重要特性就是只能通过前驱结点找到后续结点，而无法从后续结点找到前驱结点&#x3D;&#x3D;</li>
</ul>
<p><img src="https://img-blog.csdn.net/20180926161835379?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2JhaWR1XzQxODEzMzY4/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<p><img src="https://img-blog.csdn.net/20180825190821499?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L21lbmdfbGVtb24=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></p>
<table>
<thead>
<tr>
<th align="center">建立</th>
<th align="center">插入</th>
<th align="center">删除</th>
<th align="center">查找</th>
<th align="center">输出</th>
</tr>
</thead>
<tbody><tr>
<td align="center">头插法</td>
<td align="center">前插法</td>
<td align="center">删除 P 后继</td>
<td align="center">序号查找</td>
<td align="center">顺序打印</td>
</tr>
<tr>
<td align="center">尾插法</td>
<td align="center">后插法</td>
<td align="center">删除 P 本身</td>
<td align="center">值查找</td>
<td align="center"></td>
</tr>
<tr>
<td align="center">递归法</td>
<td align="center"></td>
<td align="center">按值删除</td>
<td align="center"></td>
<td align="center"></td>
</tr>
</tbody></table>
<h3 id="链表类型定义"><a href="#链表类型定义" class="headerlink" title="链表类型定义"></a>链表类型定义</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;		<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">next</span>;</span>	<span class="comment">//指针域</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PNode</span>;</span>		<span class="comment">//结点类型重命名</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">LinkList</span>;</span>	<span class="comment">//单链表类型重命名，方便区分</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>指针域为什么要定义成 <code>struct Node *</code>类型？</p>
<p>这个问题想了我二十分钟T_T，原来就是因为指针域的指针要指向下一个结点，下一个结点的数据类型就是<code>struct Node</code>类型，麻了，又是简单的问题想老半天</p>
</blockquote>
<h3 id="单链表建立和判空"><a href="#单链表建立和判空" class="headerlink" title="单链表建立和判空"></a>单链表建立和判空</h3><ul>
<li>建立带有头结点的空的单链表，为了方便后面的算法运算</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkList <span class="title function_">SetNullList_Link</span><span class="params">()</span>	<span class="comment">//创一个带有哨兵的空链表</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkList head = (LinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));	<span class="comment">//申请头结点空间</span></span><br><span class="line">    <span class="keyword">if</span>(head != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        head-&gt;next =<span class="literal">NULL</span>;	<span class="comment">//头结点的指针域赋值为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Alloc failure&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> head;	<span class="comment">//返回头结点的地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsNull_Link</span><span class="params">(LinkList head)</span>	<span class="comment">//判空函数，如果为空返回1，不为空返回0</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(head-&gt;next == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="头插法建立非空单链表"><a href="#头插法建立非空单链表" class="headerlink" title="头插法建立非空单链表"></a>头插法建立非空单链表</h4><p><img src="https://raw.githubusercontent.com/C1everF0x/Images/master/20200930005326.png" alt="步骤"></p>
<blockquote>
<p><strong>第三步和第四步不能够颠倒顺序，如果先做第四步，那么头结点会和后面的结点断开联系</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_Head</span><span class="params">(<span class="keyword">struct</span> Node *head)</span>	<span class="comment">//头插法建立非空单链表</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p = <span class="literal">NULL</span>;	<span class="comment">//建立空结点</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入整型数据建立链表，以-1结束\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;data);	<span class="comment">//输入数据域内的值</span></span><br><span class="line">    <span class="keyword">while</span>(data != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));	<span class="comment">//为空结点申请内存</span></span><br><span class="line">        p-&gt;data = data;	<span class="comment">//数据域赋值</span></span><br><span class="line">        p-&gt;next = head-&gt;next;	<span class="comment">//头结点指针域赋值给插入节点的指针域</span></span><br><span class="line">        head-&gt;next = p;	<span class="comment">//新插入结点地址赋值给head-&gt;next</span></span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;data);	<span class="comment">//输入下一个数据结点的数据域</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="尾插法建立单链表"><a href="#尾插法建立单链表" class="headerlink" title="尾插法建立单链表"></a>尾插法建立单链表</h4><p><img src="https://raw.githubusercontent.com/C1everF0x/Images/master/20200930014203.png" alt="步骤"></p>
<blockquote>
<p><strong>同样的第四步和第五步不能调换顺序，如果先做第五步，尾指针就会失去和尾结点的联系，就没办法再进行第四步了</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">CreateList_Tail</span><span class="params">(<span class="keyword">struct</span> Node *head)</span>	<span class="comment">//尾插法建立非空单链表</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">p</span> =</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">q</span> =</span> head;</span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入整型数据建立链表，以-1结束\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    <span class="keyword">while</span>(data != <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        p = (<span class="keyword">struct</span> Node*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));	<span class="comment">//为空结点申请内存</span></span><br><span class="line">        p-&gt;data = data;	<span class="comment">//新结点数据域赋值</span></span><br><span class="line">        p-&gt;next = <span class="literal">NULL</span>;	<span class="comment">//插入结点指针域赋值为NULL</span></span><br><span class="line">        q-&gt;next = p;	<span class="comment">//最后一个结点指针域指向新插入结点</span></span><br><span class="line">        q = p;	<span class="comment">//最后一个结点地址赋值给尾指针</span></span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>, &amp;data);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表查找"><a href="#单链表查找" class="headerlink" title="单链表查找"></a>单链表查找</h3><h4 id="按值查找"><a href="#按值查找" class="headerlink" title="按值查找"></a>按值查找</h4><p>找数据域值为<code>给定值x</code>的结点，找到的话，返回其第一次出现的<code>存储位置</code>，否则返回<code>NULL</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">PNode <span class="title function_">Locate_Link</span><span class="params">(LinkList llist, DataType x)</span>	<span class="comment">//传进去llist链表，查找值为x的元素</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p;	<span class="comment">//用于遍历链表的指针</span></span><br><span class="line">    <span class="keyword">if</span>(llist == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    p = llist-&gt;next;	<span class="comment">//p指针指向第一个有效结点</span></span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>&amp;&amp;p-&gt;data != x)	<span class="comment">//当 p = NULL时或 p-&gt;data=x时，退出循环，否则指针指向下一个结点</span></span><br><span class="line">        p = p-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="按照序号查找"><a href="#按照序号查找" class="headerlink" title="按照序号查找"></a>按照序号查找</h4><p>找链表中第<code>i</code>个结点，找到的话，返回该结点的<code>存储位置</code>，否则返回<code>NULL</code></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">PNode <span class="title function_">Locate_Link2</span><span class="params">(Linklist llist,<span class="type">int</span> x)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    <span class="type">int</span> flag;</span><br><span class="line">    <span class="keyword">if</span>(llist == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    p = llist-&gt;next;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>&amp;&amp;flag!=x)</span><br><span class="line">    &#123;</span><br><span class="line">        p=p-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="单链表插入"><a href="#单链表插入" class="headerlink" title="单链表插入"></a>单链表插入</h3><h4 id="后插法"><a href="#后插法" class="headerlink" title="后插法"></a>后插法</h4><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201209192825.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//在链表llist中的p位置之后插入值为x的结点</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">InsertPost_link</span><span class="params">(LinkList llist,PNode p,DataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode q;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;data don&#x27;t exist&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    q = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span>(q != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        q-&gt;data = x;</span><br><span class="line">        q-&gt;next = p-&gt;next;</span><br><span class="line">        p-&gt;next = q;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc 失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="前插法"><a href="#前插法" class="headerlink" title="前插法"></a>前插法</h4><blockquote>
<p><strong>前插法首先要找到p的前驱结点pre，然后转化为后插法来插入</strong></p>
</blockquote>
<p><img src="https://raw.githubusercontent.com/C1everF0x/Images/master/20200930100744.png" alt="步骤"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">InsertPre_link</span><span class="params">(LinkList llist.PNode p,DataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    Pnode prt = llist;</span><br><span class="line">    PNode q = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(pre-&gt;next != p)	</span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    q = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span>(	q ==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    q-&gt;data = x;</span><br><span class="line">    q-&gt;next = p;</span><br><span class="line">    pre-&gt;next = q;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表删除"><a href="#单链表删除" class="headerlink" title="单链表删除"></a>单链表删除</h3><h4 id="删除结点的后继"><a href="#删除结点的后继" class="headerlink" title="删除结点的后继"></a>删除结点的后继</h4><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201209193833.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelPostionNext_Link</span><span class="params">(LinkList head,PNode r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(r-&gt;next)</span><br><span class="line">    &#123;</span><br><span class="line">        PNode p = r-&gt;next;</span><br><span class="line">    	r-&gt;next = p-&gt;next;</span><br><span class="line">    	<span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="删除结点本身"><a href="#删除结点本身" class="headerlink" title="删除结点本身"></a>删除结点本身</h4><blockquote>
<p>删除结点本身需要先找到结点的前驱，然后转化为删除结点的后继来做</p>
</blockquote>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201209193938.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DelPostion_Link</span><span class="params">(LinkList head,PNode r)</span></span><br><span class="line">&#123;</span><br><span class="line">	PNode  pre = head; </span><br><span class="line">	<span class="keyword">while</span>(pre-&gt;next != r)</span><br><span class="line">    &#123;</span><br><span class="line">        pre = pre-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    pre-&gt;next = r-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="按值删除"><a href="#按值删除" class="headerlink" title="按值删除"></a>按值删除</h4><blockquote>
<p>按值删除的原理就是用两个指针一前一后遍历链表，后面的指针找到要删除结点之后把指针域赋值给前一个指针的指针域，然后自我释放，原理等同于删除自身结点的算法</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//删除第一个与输入参数data相等的值的结点</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">DelValue_Link</span><span class="params">(LinkList head,<span class="type">int</span> data)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p = head-&gt;next;</span><br><span class="line">    PNode before_p = head;</span><br><span class="line">    <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == data)</span><br><span class="line">        &#123;</span><br><span class="line">            before_p-&gt;next = p-&gt;next;</span><br><span class="line">            <span class="built_in">free</span>(p);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = p-&gt;next;</span><br><span class="line">            before_p = before_p-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单链表逆置"><a href="#单链表逆置" class="headerlink" title="单链表逆置"></a>单链表逆置</h3><blockquote>
<p><strong>这是在课堂上当堂练习的内容，记录下来，直接贴算法吧</strong></p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Reverse</span><span class="params">(LinkList H)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode a,b;</span><br><span class="line">    a = H-&gt;next;    <span class="comment">//用一个指针记录下第一个结点</span></span><br><span class="line">    H-&gt;next = <span class="literal">NULL</span>; <span class="comment">//头结点指针域置空，把头结点独出来</span></span><br><span class="line">    <span class="keyword">while</span>(a)        <span class="comment">//进入循环，循环到最后一个结点为NULL时结束循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        b = a;                  <span class="comment">//用另一个指针记录下后继结点</span></span><br><span class="line">        a = a-&gt;next;            <span class="comment">//移动到下一个结点</span></span><br><span class="line">        b-&gt;next = H-&gt;next;      <span class="comment">//头结点指针域指向分离出来的那个结点</span></span><br><span class="line">        H-&gt;next = b;            <span class="comment">//不懂怎么表达这句话的意思</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><del>单循环链表和双循环链表记得更新</del></p>
<p>已更新</p>
</blockquote>
<h3 id="单循环链表"><a href="#单循环链表" class="headerlink" title="单循环链表"></a>单循环链表</h3><p>为了解决知道链表中某个结点的位置而无法找到其前驱的问题，引入了循环链表，就是<strong>让最后一个结点指向头结点</strong></p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201209195611.png"></p>
<p>为了方便利用，多采用<strong>尾指针</strong><code>rear</code>来表示单循环链表，头结点则表示为<code>rear-&gt;next</code>，第一个结点则表示为<code>rear-&gt;next-&gt;next</code></p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201209195643.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//建立尾指针表示的单循环链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span>&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    PNode next;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">CLinkList</span>;</span></span><br><span class="line">CLinkList <span class="title function_">createListRearCircle</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode rear;</span><br><span class="line">    Pnode s;</span><br><span class="line">    <span class="type">int</span> x;</span><br><span class="line">    CLinkList head = (CLinkList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CLinkList));</span><br><span class="line">    head-&gt;next = head;</span><br><span class="line">    rear = head;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入整型数据建立链表，以-1结束\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d&quot;</span>&amp;x);</span><br><span class="line">    whlie(x!=<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        s = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(CLinkList));</span><br><span class="line">        s-&gt;data = x;</span><br><span class="line">        s-&gt;next = head;</span><br><span class="line">        rear-&gt;next = s;</span><br><span class="line">        rear = s;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d&quot;</span>,&amp;x);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> rear;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="两个单循环链表合并成一个新的单循环链表"><a href="#两个单循环链表合并成一个新的单循环链表" class="headerlink" title="两个单循环链表合并成一个新的单循环链表"></a>两个单循环链表合并成一个新的单循环链表</h4><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201209202024.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">CLinkList <span class="title function_">Combine</span><span class="params">(CLinkList a,CLinkList b)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p = a-&gt;next;</span><br><span class="line">    a-&gt;next = b-&gt;next-&gt;next;</span><br><span class="line">    <span class="built_in">free</span>(b-&gt;next);</span><br><span class="line">    b-&gt;next = p;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双链表和双循环链表"><a href="#双链表和双循环链表" class="headerlink" title="双链表和双循环链表"></a>双链表和双循环链表</h3><h4 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h4><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201209202806.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span>		//双链表结点类型</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">llink</span>;</span>	<span class="comment">//前驱指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">rlink</span>;</span>	<span class="comment">//后继指针</span></span><br><span class="line">&#125;Dlnode;</span><br><span class="line"><span class="keyword">typedef</span>					<span class="comment">//头尾结点指针类型（head）</span></span><br><span class="line">&#123;</span><br><span class="line">    DLnode *first;</span><br><span class="line">    DLnode *last;</span><br><span class="line">&#125;DLinkList;</span><br><span class="line">DLinkList *dlist;</span><br></pre></td></tr></table></figure>

<h4 id="双链表删除"><a href="#双链表删除" class="headerlink" title="双链表删除"></a>双链表删除</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Del_DoubleList</span><span class="params">(DLinkList dlist,Dlnode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    p-&gt;llink-&gt;rlink = p-&gt;rlink;</span><br><span class="line">    p-&gt;rlink-&gt;llink = p-&gt;llink;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双链表插入"><a href="#双链表插入" class="headerlink" title="双链表插入"></a>双链表插入</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Insert_DoubleList</span><span class="params">(Dlnode *p)</span></span><br><span class="line">&#123;</span><br><span class="line">    Dlnode s = (Dlnode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Dlnode));</span><br><span class="line">    <span class="keyword">if</span>(s)</span><br><span class="line">    &#123;</span><br><span class="line">        s-&gt;llink = p;</span><br><span class="line">        s-&gt;rlink = p-&gt;rlink;</span><br><span class="line">        p-&gt;rlink-&gt;llink = s;</span><br><span class="line">        p-&gt;rlink = s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc失败\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="双循环链表"><a href="#双循环链表" class="headerlink" title="双循环链表"></a>双循环链表</h4><blockquote>
<p>把双链表最后一个结点的后继指针指向第一个结点，把第一个结点的前驱指针指向最后一个结点，就组成了双循环链表</p>
</blockquote>
<h1 id="第三章-栈和队列"><a href="#第三章-栈和队列" class="headerlink" title="第三章 栈和队列"></a>第三章 栈和队列</h1><ul>
<li><strong>栈和队列其实是线性表的特例，特殊性在于它们都是操作受限的线性表</strong></li>
</ul>
<h2 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h2><ul>
<li>栈限定在表尾进行插入或删除，表尾端称<strong>栈顶</strong>，表头端称<strong>栈底</strong></li>
<li><strong>后进先出</strong></li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201210203545.png"></p>
<h3 id="栈混洗"><a href="#栈混洗" class="headerlink" title="栈混洗"></a>栈混洗</h3><ul>
<li>n个数据以此进栈，随时可能出栈，按照出栈顺序得到的一个序列，称为一个栈混洗</li>
<li>任一前缀中的 push 不少于 pop ，则该序列也必然对应一个栈混洗</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/20201013235541.png" alt="栈混洗"></p>
<h3 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h3><ul>
<li><strong>静态结构，需提前分配存储空间</strong></li>
<li><strong>注意判断栈满或栈空</strong></li>
</ul>
<h4 id="顺序栈类型定义"><a href="#顺序栈类型定义" class="headerlink" title="顺序栈类型定义"></a>顺序栈类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Stack</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> MAX;	<span class="comment">//最大容量</span></span><br><span class="line">    <span class="type">int</span> top;	<span class="comment">//栈顶指针</span></span><br><span class="line">    DataType *elem;	<span class="comment">//存放元素的数组的起始指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Stack</span> *<span class="title">SeqStack</span>	//定义顺序栈类型</span></span><br></pre></td></tr></table></figure>

<h4 id="创建空栈"><a href="#创建空栈" class="headerlink" title="创建空栈"></a>创建空栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">SeqStack <span class="title function_">SetNullStack_Seq</span><span class="params">(<span class="type">int</span> m)</span>	<span class="comment">//创建空顺序栈，m 为分配的最大空间</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqStack sstack = (SeqStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Stack));</span><br><span class="line">    <span class="keyword">if</span>(sstack != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        sstack-&gt;elem = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>) * m);</span><br><span class="line">        <span class="keyword">if</span>(sstack-&gt;elem != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sstack-&gt;MAX = m;		<span class="comment">//顺序栈最大容量</span></span><br><span class="line">            sstack-&gt;top = <span class="number">-1</span>;		<span class="comment">//设置栈顶初值为1</span></span><br><span class="line">            <span class="keyword">return</span>(sstack);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">free</span>(sstack);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        pritnf(<span class="string">&quot;Alloc failure!&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/20201014001548.png" alt="顺序栈模型"></p>
<h4 id="顺序栈判空"><a href="#顺序栈判空" class="headerlink" title="顺序栈判空"></a>顺序栈判空</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsNullStack_seq</span><span class="params">(SeqStack sstack)</span>		<span class="comment">//判空函数</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(sstack-&gt;top == <span class="number">-1</span>);		<span class="comment">//栈顶元素 top 用来判断，如果为空返回 1 ，如果不为空返回 0 </span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进栈"><a href="#进栈" class="headerlink" title="进栈"></a>进栈</h4><ul>
<li><strong>需要检查栈是否已满</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push_seq</span><span class="params">(SeqStack sstack, <span class="type">int</span> x)</span>		<span class="comment">//入栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(sstack-&gt;top &gt;= (sstack-&gt;MAX - <span class="number">1</span>))	<span class="comment">//检查栈满函数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈满了，再加栈溢出了!&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sstack-&gt;top ++;		<span class="comment">//修改栈顶变量</span></span><br><span class="line">        sstack-&gt;elem[sstack-&gt;top] = x;		<span class="comment">//把元素放进栈顶变量的位置中</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p><strong><code>sstack-&gt;top</code>用来表示数组下标</strong></p>
<p><strong>必须先修改栈顶指针，<code>sstack-&gt;top++</code>，然后再把元素放进去</strong></p>
</blockquote>
<h4 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h4><ul>
<li><strong>需要检查栈是否已空</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pop_seq</span><span class="params">(SeqStack sstack)</span>		<span class="comment">//出栈</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsNullStack_seq(sstack))		<span class="comment">//调用判断栈空函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空了!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sstack-top = sstack-top - <span class="number">1</span>;<span class="comment">//栈顶-1</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取栈顶元素"><a href="#取栈顶元素" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><ul>
<li><strong>需要检查栈是否已空</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataType <span class="title function_">Top_seq</span><span class="params">(SeqStack sstack)</span>		<span class="comment">//取栈顶元素的值</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsNullStack_seq(sstack))		<span class="comment">//调用判断栈空函数</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;栈空了!&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> sstack-&gt; elem[sstack-&gt;top];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h3><ul>
<li><strong>用链式存储的栈， top 指向栈顶元素，栈底在链表尾部</strong></li>
<li><strong>指针从栈顶开始，往栈底方向链接，有头结点</strong></li>
<li><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/20201014002909.png" alt="链栈模型"></li>
</ul>
<h4 id="链栈类型定义"><a href="#链栈类型定义" class="headerlink" title="链栈类型定义"></a>链栈类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span>* <span class="title">next</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PNode</span>;</span>					<span class="comment">//结点类型</span></span><br><span class="line">typedet <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">top</span>, *<span class="title">LinkStack</span>;</span>		<span class="comment">//栈顶和链栈类型</span></span><br></pre></td></tr></table></figure>

<h4 id="创建空栈-1"><a href="#创建空栈-1" class="headerlink" title="创建空栈"></a>创建空栈</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">LinkStack <span class="title function_">SetNullStack_Link</span><span class="params">()</span>		<span class="comment">//创建空链栈</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkStack top = (LinkStack)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));</span><br><span class="line">    <span class="keyword">if</span>(top != <span class="literal">NULL</span>)</span><br><span class="line">        top-&gt;next = <span class="literal">NULL</span>;			<span class="comment">//头结点指针域置空</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Alloc failure&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> top;						<span class="comment">//返回栈顶指针</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断栈空"><a href="#判断栈空" class="headerlink" title="判断栈空"></a>判断栈空</h4><ul>
<li>判断栈顶结点的指针域是否为<code>NULL</code>，空则返回1，否则返回0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsNullStack_link</span><span class="params">(LinkStack top)</span>		<span class="comment">//判断链栈是否为空</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(top-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;	<span class="comment">//为空返回1</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;	<span class="comment">//不为空返回0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="进栈-1"><a href="#进栈-1" class="headerlink" title="进栈"></a>进栈</h4><ul>
<li><strong>进栈操作的关键点和链表的关键点一样：&#x3D;&#x3D;只能是前驱找后继，后继找不到前驱&#x3D;&#x3D;，所以进栈的指针指向顺序有讲究</strong><ol>
<li><strong>头结点指针域赋值给要插入元素指针域</strong></li>
<li><strong>头结点指针域指向要插入元素</strong></li>
</ol>
</li>
<li><strong>栈的插入操作只能是在栈顶，即在头结点处进行进栈操作</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Push_link</span><span class="params">(LinkStack top, DataType x)</span>;			<span class="comment">//进栈</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    p = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> Node));			<span class="comment">//申请结点空间</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Alloc failure&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data = x;								<span class="comment">//数据域赋值</span></span><br><span class="line">        p-&gt;next = top-&gt;next;						<span class="comment">//指针域赋值</span></span><br><span class="line">        top-&gt;next = p; 								<span class="comment">//修改栈顶</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/20201014005501.png" alt="进栈模型"></p>
<h4 id="出栈-1"><a href="#出栈-1" class="headerlink" title="出栈"></a>出栈</h4><ul>
<li><strong>出栈需要判空，需要释放结点空间</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Pop_link</span><span class="params">(LinkStack top)</span>		<span class="comment">//删除栈顶元素</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    <span class="keyword">if</span>(IsNullStack_link(top))		<span class="comment">//判断栈空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是空的&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = top-&gt;next;				<span class="comment">//p 指向待删除结点</span></span><br><span class="line">        top-&gt;next = p-&gt;next;		<span class="comment">//修改栈顶指针</span></span><br><span class="line">        <span class="built_in">free</span>(p);					<span class="comment">//释放删除结点空间</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取栈顶元素-1"><a href="#取栈顶元素-1" class="headerlink" title="取栈顶元素"></a>取栈顶元素</h4><ul>
<li><strong>需要判空</strong></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">DataType <span class="title function_">Top_link</span><span class="params">(LinkStack top)</span>	<span class="comment">//删除栈顶元素</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsNullStack_link(top))		<span class="comment">//判断栈空</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;是空的&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> top-&gt;next-&gt;data;		<span class="comment">//头结点指针域指向的就是栈顶的结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里以后有空要记得补上栈的应用的一些代码</p>
</blockquote>
<h3 id="栈实现：进制转换"><a href="#栈实现：进制转换" class="headerlink" title="栈实现：进制转换"></a>栈实现：进制转换</h3><h4 id="转八进制"><a href="#转八进制" class="headerlink" title="转八进制"></a>转八进制</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Conversion</span><span class="params">(LinkStack ps, <span class="type">int</span> n)</span>	<span class="comment">//十进制转八进制</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        Push_link(ps,n%<span class="number">8</span>);</span><br><span class="line">        n/=<span class="number">8</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果为:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!IsNullStack_Link(ps))</span><br><span class="line">    &#123;</span><br><span class="line">        temp = Top_link(ps);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,temp);</span><br><span class="line">        Pop_link(ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="转十六进制"><a href="#转十六进制" class="headerlink" title="转十六进制"></a>转十六进制</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Hexconversion</span><span class="params">(LinkStack ps,<span class="type">int</span> n)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> temp;</span><br><span class="line">    <span class="keyword">while</span>(n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> temp = n%<span class="number">16</span>;</span><br><span class="line">        <span class="keyword">switch</span>(temp)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">10</span>:temp = <span class="string">&#x27;A&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">11</span>:temp = <span class="string">&#x27;B&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">12</span>:temp = <span class="string">&#x27;C&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">13</span>:temp = <span class="string">&#x27;D&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">14</span>:temp = <span class="string">&#x27;E&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">15</span>:temp = <span class="string">&#x27;F&#x27;</span>;<span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Push_link(ps,temp);</span><br><span class="line">        n/=<span class="number">16</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;结果为:&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(!IsNullStack_Link(ps))</span><br><span class="line">    &#123;</span><br><span class="line">        temp = Top_link(ps);</span><br><span class="line">        <span class="keyword">if</span>(temp&lt;<span class="number">10</span>)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,temp);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        	<span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,temp);</span><br><span class="line">        Pop_link(ps);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈实现：括号匹配"><a href="#栈实现：括号匹配" class="headerlink" title="栈实现：括号匹配"></a>栈实现：括号匹配</h3><ul>
<li><p>算法思路</p>
<ul>
<li><p>所有的左括号都进栈，设置标志位<code>flag</code>为1</p>
</li>
<li><p>遇到右括号开始匹配，首先检查栈是否为空</p>
<ul>
<li><p>如果栈空，表示匹配失败，右括号多了</p>
</li>
<li><p>如果栈不空</p>
<ul>
<li><p>如果匹配到左括号，左括号出栈</p>
</li>
<li><p>如果不匹配，<code>flag</code>设为0</p>
</li>
</ul>
</li>
</ul>
</li>
<li><p>检验结束时</p>
<ul>
<li><strong>栈不为空或者<code>flag</code>为0</strong>，则表示匹配不成功</li>
<li><strong>栈空</strong>，则表示匹配成功</li>
</ul>
</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BracketMatch</span><span class="params">(LinkStack top)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> flag = <span class="number">1</span>;</span><br><span class="line">   	<span class="type">char</span> ch,temp;</span><br><span class="line">    Push_link(top,<span class="string">&#x27;#&#x27;</span>);	<span class="comment">//栈底放#，结束标志位</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;输入要判断表达式，用#表示结束：\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(ch = <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Push_link(top,ch);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(ch = <span class="string">&#x27;)&#x27;</span>&amp;&amp;!IsNullStack_Link(top))</span><br><span class="line">            &#123;</span><br><span class="line">                temp = Top_link(top);</span><br><span class="line">                <span class="keyword">if</span>(temp == <span class="string">&#x27;(&#x27;</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    Pop_link(top);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    flag = <span class="number">0</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        scanf_s(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!flag||Top_link(top)!=<span class="string">&#x27;#&#x27;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;no\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;yes\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h2><ul>
<li>队列限定在一端进行插入、一端进行删除，插入端称<strong>队尾</strong>，删除端称<strong>队头</strong></li>
<li><strong>先进先出</strong></li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201210203612.png"></p>
<blockquote>
<p>队列会存在假溢出的情况，即当前队列并不满，但是不能入队</p>
<p>原因：被删除的元素的空间没有再被使用</p>
<p>解决：循环队列</p>
</blockquote>
<h3 id="循环队列"><a href="#循环队列" class="headerlink" title="循环队列"></a>循环队列</h3><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201211050316.png"></p>
<h4 id="循环队列类型定义"><a href="#循环队列类型定义" class="headerlink" title="循环队列类型定义"></a>循环队列类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> Max;		<span class="comment">//队列空间最大值</span></span><br><span class="line">    <span class="type">int</span> f,r;		<span class="comment">//队头指针和队尾指针</span></span><br><span class="line">    DataType *elem;	<span class="comment">//队列元素空间</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> *<span class="title">SeqQueue</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建空队列"><a href="#创建空队列" class="headerlink" title="创建空队列"></a>创建空队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">SeqQueue <span class="title function_">SetNullQueue_Seq</span><span class="params">(<span class="type">int</span> m)</span></span><br><span class="line">&#123;</span><br><span class="line">    SeqQueue squeue;</span><br><span class="line">    squeue = (SeqQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqQueue));</span><br><span class="line">    <span class="keyword">if</span>(squeue == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        squeue-elem = (<span class="type">int</span> *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DataType)*m);</span><br><span class="line">        squeue-&gt;Max = m;</span><br><span class="line">        squeue-&gt;f = <span class="number">0</span>;</span><br><span class="line">        squeue-&gt;r = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> squeue;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断队空"><a href="#判断队空" class="headerlink" title="判断队空"></a>判断队空</h4><ul>
<li>检查队头和队尾指针是否相等，如果相等为空队列，返回1，否则返回0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsNullQueue_seq</span><span class="params">(SeqQueue Squeue)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> (squeue-&gt;f == squeue-&gt;r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h4><ul>
<li>若队列没满，在队尾添加元素，修改队尾指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue_seq</span><span class="params">(Sequeue Squeue, DataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>((squeue-&gt;r+<span class="number">1</span>)%squeue-&gt;Max == squeue-&gt;f)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列已满\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        squeue-&gt;elem[squeue-&gt;r] = x;				<span class="comment">//插入元素x</span></span><br><span class="line">        squeue-&gt;r = (squeue-&gt;r+<span class="number">1</span>) % (squeue-&gt;Max);	<span class="comment">//队尾指针++</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h4><ul>
<li>首先判断队列是否为空，非空则删除队头元素，修改队头指针</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeQueue_seq</span><span class="params">(SeqQueue squeue)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsNullQueue_seq(squeue))</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列是空的\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        squeue-f = (squeue-&gt;f+<span class="number">1</span>)%(squeue-&gt;Max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取队头元素"><a href="#取队头元素" class="headerlink" title="取队头元素"></a>取队头元素</h4><ul>
<li>首先判断队列是否为空，非空则返回队头元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">DataType <span class="title function_">FrontQueue_seq</span><span class="params">(SeqQueue squeue)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(squeue-&gt;f == squeue-&gt;r)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列是空的\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> squeue-&gt;elem[squeue-&gt;f];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="链队列"><a href="#链队列" class="headerlink" title="链队列"></a>链队列</h3><h4 id="链队列类型定义"><a href="#链队列类型定义" class="headerlink" title="链队列类型定义"></a>链队列类型定义</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> DataType;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">link</span>;</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> *<span class="title">PNode</span>;</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Queue</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    PNode f;	<span class="comment">//队头指针</span></span><br><span class="line">   	PNode r;	<span class="comment">//队尾指针</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Queue</span> *<span class="title">LinkQueue</span>;</span></span><br></pre></td></tr></table></figure>

<h4 id="创建空队列-1"><a href="#创建空队列-1" class="headerlink" title="创建空队列"></a>创建空队列</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">LinkQueue <span class="title function_">SetNullQueue_Link</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue lqueue;</span><br><span class="line">    lqueue = (LinkQueue)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue));</span><br><span class="line">    <span class="keyword">if</span>(lqueue!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        lqueue-&gt;f = <span class="literal">NULL</span>;</span><br><span class="line">        lqueue-&gt;r = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> lqueue;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="判断队空-1"><a href="#判断队空-1" class="headerlink" title="判断队空"></a>判断队空</h4><ul>
<li>检查队头指针，如果为空，返回1，否则返回0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">IsNullQueue_Link</span><span class="params">(LinkQueue lqueue)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span>(lqueue-&gt;f == <span class="literal">NULL</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h4><ul>
<li>申请结点，数据域指针域赋值<ul>
<li>如果是第一个结点，特殊处理，队头和队尾指针都指向该结点</li>
<li>如果不是第一个结点，则在队尾插入，修改队尾指针</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">EnQueue_link</span><span class="params">(LinkQueue lqueue,DataType x)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    p = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PNode));</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc失败\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p-&gt;data = x;</span><br><span class="line">        p-&gt;link =<span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(lqueue-&gt;f == lqueue-&gt;r)</span><br><span class="line">        &#123;</span><br><span class="line">            lqueue-&gt;f = p;</span><br><span class="line">            lqueue-&gt;r = p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            lqueue-&gt;r-&gt;link = p;</span><br><span class="line">            lqueue-&gt;r = p;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h4><ul>
<li>首先判断队列是否为空，非空则修改队头指针并释放队头结点空间</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DeQueue_link</span><span class="params">(LinkQueue lqueue)</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p;</span><br><span class="line">    <span class="keyword">if</span>(IsNullQueue_Link)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空\n&quot;</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = lqueue-&gt;f;</span><br><span class="line">        lqueue-&gt;f = lqueue-&gt;f-&gt;link;</span><br><span class="line">        <span class="built_in">free</span>(p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="取队头元素-1"><a href="#取队头元素-1" class="headerlink" title="取队头元素"></a>取队头元素</h4><ul>
<li>首先判断队列是否为空，非空返回队头元素</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">DataType <span class="title function_">FrontQueue_link</span><span class="params">(LinkQueue lqueue)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(IsNullQueue_Link)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;队列为空\n&quot;</span>);</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> lqueue-&gt;f-&gt;data;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h3><blockquote>
<p>同时具备栈和队列的性质的数据结构，既可以在头部和尾部插入和删除元素的数据结构</p>
<blockquote>
<p>具体的东西以后学了再补上来</p>
</blockquote>
</blockquote>
<h1 id="第四章-树与二叉树"><a href="#第四章-树与二叉树" class="headerlink" title="第四章 树与二叉树"></a>第四章 树与二叉树</h1><h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><ul>
<li>二叉树是结点的有限集合</li>
<li>这个集合可以是空集，也可以是一个称为<code>根</code>和两棵不相交的分别为<code>左子树和右子树</code>的二叉树组成</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201212201323.png"></p>
<h2 id="二叉树基本术语"><a href="#二叉树基本术语" class="headerlink" title="二叉树基本术语"></a>二叉树基本术语</h2><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201212201718.png"></p>
<ul>
<li><p><code>祖先</code>：最早的根节点，A就是整个二叉树的祖先</p>
<p><code>父结点</code>：A就是B和C的父结点，B是D的父结点</p>
<p><code>子结点</code>：B和C就是A的子结点</p>
</li>
<li><p><code>兄弟结点</code>：处在同一父母结点的结点，互称兄弟结点，B和C就是兄弟结点</p>
</li>
<li><p><code>结点的度</code>：结点的孩子的个数，A的度为2</p>
</li>
<li><p><code>树叶和分支结点</code>：度为0的叫<code>树叶</code>，其他都叫<code>分支结点</code></p>
</li>
<li><p><code>路径</code>：连接的边</p>
<p><code>路径长度</code>：层数</p>
</li>
<li><p><code>结点的层数（约定根结点为0）</code>：B、C的层数就是1，D、E和F的层数就是2</p>
</li>
<li><p><code>二叉树的高度</code>：二叉树当中最大的层数，就是高度，G的层数是3，高度为3</p>
</li>
<li><p><code>B</code>：分支</p>
</li>
</ul>
<h2 id="特殊的二叉树"><a href="#特殊的二叉树" class="headerlink" title="特殊的二叉树"></a>特殊的二叉树</h2><h3 id="满二叉树"><a href="#满二叉树" class="headerlink" title="满二叉树"></a>满二叉树</h3><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201212202559.png"></p>
<h3 id="完全二叉树"><a href="#完全二叉树" class="headerlink" title="完全二叉树"></a>完全二叉树</h3><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201212202649.png"></p>
<h3 id="扩充二叉树"><a href="#扩充二叉树" class="headerlink" title="扩充二叉树"></a>扩充二叉树</h3><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201212202818.png"></p>
<h2 id="二叉树的性质"><a href="#二叉树的性质" class="headerlink" title="二叉树的性质"></a>二叉树的性质</h2><ul>
<li><p>在非空二叉树的第&#x3D;&#x3D;i&#x3D;&#x3D;层上至多有&#x3D;&#x3D;2^j^&#x3D;&#x3D;个结点(&#x3D;&#x3D;i&gt;&#x3D;0&#x3D;&#x3D;)</p>
<p>归纳证明：&#x3D;&#x3D;i &#x3D; 0&#x3D;&#x3D;，&#x3D;&#x3D;结点数&#x3D;1&#x3D;2^0^&#x3D;&#x3D;，假设对于&#x3D;&#x3D;j(0&lt;&#x3D;j&lt;&#x3D;i)&#x3D;&#x3D;，结点数至多有&#x3D;&#x3D;2^j^&#x3D;&#x3D;，对于&#x3D;&#x3D;i&#x3D;j+1&#x3D;&#x3D;，结点数至多有&#x3D;&#x3D;2*2^j^&#x3D;2^j+1^&#x3D;&#x3D;</p>
</li>
<li><p>深度为 &#x3D;&#x3D;k&#x3D;&#x3D;的二叉树至多有&#x3D;&#x3D;2^k+1^-1&#x3D;&#x3D;个结点(&#x3D;&#x3D;k&gt;&#x3D;0&#x3D;&#x3D;)</p>
</li>
<li><p>对任何一棵非空二叉树T，如果叶结点个数为&#x3D;&#x3D;n<del>0</del>&#x3D;&#x3D;，度为2的结点数位&#x3D;&#x3D;n<del>2</del>&#x3D;&#x3D;，则&#x3D;&#x3D;n<del>0</del>&#x3D;n<del>2</del>+1&#x3D;&#x3D;</p>
</li>
</ul>
<h2 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h2><ul>
<li>沿某条搜索路径访问二叉树，对二叉树中的每个结点<code>访问一次且仅访问一次</code></li>
<li>遍历一棵非空二叉树<ul>
<li>访问根节点 D </li>
<li>遍历左子树 L</li>
<li>遍历右子树 R</li>
</ul>
</li>
</ul>
<h3 id="二叉树的深度遍历"><a href="#二叉树的深度遍历" class="headerlink" title="二叉树的深度遍历"></a>二叉树的深度遍历</h3><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><ul>
<li>按照<code>D-&gt;L-&gt;R</code>的顺序访问结点<ol>
<li>访问根节点</li>
<li><code>先根次序</code>遍历<code>D</code>的左子树</li>
<li><code>先根次序</code>遍历<code>D</code>的右子树</li>
</ol>
</li>
<li>伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)					<span class="comment">//结束递归的条件</span></span><br><span class="line">        <span class="keyword">return</span>;					</span><br><span class="line">    Visit(root(bt));				<span class="comment">//访问结点的数据域</span></span><br><span class="line">    PreOrder(leftchild(bt));		<span class="comment">//先根递归遍历t的左子树</span></span><br><span class="line">    PreOrder(rightchild(bt));	<span class="comment">//先根递归遍历t的右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201213220117.png"></p>
<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><ul>
<li>按照<code>L-&gt;D-&gt;R</code>的顺序访问结点<ol>
<li><code>对称次序</code>遍历左子树</li>
<li>访问根结点</li>
<li><code>对称次序</code>遍历右子树</li>
</ol>
</li>
<li>伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)				<span class="comment">//结束递归的条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrder(leftchild(bt));	<span class="comment">//对称递归遍历t的左子树</span></span><br><span class="line">    Visit(root(bt));			<span class="comment">//访问结点的数据域</span></span><br><span class="line">    InOrder(rightchild(bt));	<span class="comment">//对称递归遍历t的右子树</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><ul>
<li>按照<code>L-&gt;R-&gt;D</code>的顺序访问结点<ol>
<li><code>后根次序</code>遍历左子树</li>
<li><code>后根次序</code>遍历右子树</li>
<li>访问根节点</li>
</ol>
</li>
<li>伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder</span><span class="params">(BinTree bt)</span>;</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)					<span class="comment">//结束递归的条件</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrder(leftchild(bt));	<span class="comment">//后根递归遍历t的左子树</span></span><br><span class="line">    PostOrder(rightchild(bt));	<span class="comment">//后根递归遍历t的右子树</span></span><br><span class="line">    Visit(root(bt));				<span class="comment">//访问结点的数据域</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<hr>
<p>举例：</p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201212211638.png"></p>
<h3 id="二叉树的广度遍历（层次遍历）"><a href="#二叉树的广度遍历（层次遍历）" class="headerlink" title="二叉树的广度遍历（层次遍历）"></a>二叉树的广度遍历（层次遍历）</h3><ul>
<li>从二叉树的第一层开始，&#x3D;&#x3D;从上到下逐层遍历，在同一层中，从左到右逐个遍历&#x3D;&#x3D;</li>
<li>伪代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BinTree(bt))</span></span><br><span class="line">&#123;</span><br><span class="line">    初始化队列 q;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">while</span>(队列不空)</span><br><span class="line">    &#123;</span><br><span class="line">        出队元素 p;</span><br><span class="line">        visit(p);				<span class="comment">//访问队头结点的数据域</span></span><br><span class="line">        <span class="keyword">if</span>(leftchild(p)!=<span class="literal">NULL</span>)	<span class="comment">//队头左孩子不为空则让左孩子入队</span></span><br><span class="line">            leftchild(p) 入队q;</span><br><span class="line">        <span class="keyword">if</span>(rightchild(p)!=<span class="literal">NULL</span>)	<span class="comment">//队头右孩子不为空则让右孩子入队</span></span><br><span class="line">            rightchild(p) 入队q;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的交叉遍历"><a href="#二叉树的交叉遍历" class="headerlink" title="二叉树的交叉遍历"></a>二叉树的交叉遍历</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    visit(bt);</span><br><span class="line">    InOrder(lefchild(bt));</span><br><span class="line">    InOrder(rightchild(bt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">InOrder</span><span class="params">(BinTree bt)</span>)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PreOrder(leftchild(bt));</span><br><span class="line">    visit(bt);</span><br><span class="line">    PreOrder(rightchild(bt));</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    bt = CreateBinTree();</span><br><span class="line">    PreOrder(bt);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201214135713.png"></p>
<h2 id="二叉树的重构"><a href="#二叉树的重构" class="headerlink" title="二叉树的重构"></a>二叉树的重构</h2><ul>
<li>由遍历序列恢复二叉树</li>
</ul>
<p>&#x3D;&#x3D;已知先根序列和对称序列可以恢复二叉树&#x3D;&#x3D;</p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201214124613.png"></p>
<p>&#x3D;&#x3D;已知对称序列和后根序列也可以恢复二叉树&#x3D;&#x3D;</p>
<p>&#x3D;&#x3D;已知先根序列和后根序列对于满二叉树可以恢复，其他不行&#x3D;&#x3D;</p>
<blockquote>
<p>因为满二叉树每个结点都有左孩子和右孩子</p>
</blockquote>
<ul>
<li>先根序列找左孩子</li>
<li>后跟序列找右孩子</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201214125338.png"></p>
<p>a</p>
<h2 id="二叉树的存储"><a href="#二叉树的存储" class="headerlink" title="二叉树的存储"></a>二叉树的存储</h2><h3 id="二叉树的顺序存储（完全二叉树）"><a href="#二叉树的顺序存储（完全二叉树）" class="headerlink" title="二叉树的顺序存储（完全二叉树）"></a>二叉树的顺序存储（完全二叉树）</h3><ul>
<li>用一组地址连续的存储单元按层次次序依次存储的结点</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201214143025.png"></p>
<h3 id="二叉树的链式存储（一般二叉树）"><a href="#二叉树的链式存储（一般二叉树）" class="headerlink" title="二叉树的链式存储（一般二叉树）"></a>二叉树的链式存储（一般二叉树）</h3><p>二叉链表：</p>
<blockquote>
<p>二叉链表中，无法通过结点直接找到其双亲</p>
<blockquote>
<p>解决办法是在结点中增加一个父结点指针域，转化为三叉链表</p>
</blockquote>
</blockquote>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201214143139.png"></p>
<p>类型定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTeeNode</span> *<span class="title">leftchild</span>;</span></span><br><span class="line">    structBTreeNode *rightchild;</span><br><span class="line">&#125;BinTreeNode;</span><br><span class="line"><span class="keyword">typedef</span> BinTreeNode *BinTree;</span><br></pre></td></tr></table></figure>



<h3 id="线索二叉树"><a href="#线索二叉树" class="headerlink" title="线索二叉树"></a>线索二叉树</h3><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201215041515.png"></p>
<ul>
<li>类型定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">char</span> DataType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    DataType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span> *<span class="title">leftchild</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BTreeNode</span> *<span class="title">rightchild</span>;</span></span><br><span class="line">    <span class="type">int</span> lthread;</span><br><span class="line">    <span class="type">int</span> rthread;</span><br><span class="line">&#125;BinTreeNode;</span><br><span class="line"><span class="keyword">typedef</span> BinTreeNode *BinTree;</span><br></pre></td></tr></table></figure>

<h2 id="（递归）二叉树的建立与遍历"><a href="#（递归）二叉树的建立与遍历" class="headerlink" title="（递归）二叉树的建立与遍历"></a>（递归）二叉树的建立与遍历</h2><ul>
<li>建立：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">CreateBinTree_Recursion</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    BinTree bt;</span><br><span class="line">    scanf_s(<span class="string">&quot;%c&quot;</span>,&amp;ch);</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">&#x27;@&#x27;</span>)</span><br><span class="line">        bt == <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        bt = (BinTreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));</span><br><span class="line">        bt-&gt;data = ch;</span><br><span class="line">        bt-&gt;leftchild = CreateBinTree_Recuision();</span><br><span class="line">        bt-&gt;rightchild = CreateBinTree_Recuision();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先序遍历-1"><a href="#先序遍历-1" class="headerlink" title="先序遍历"></a>先序遍历</h3><ul>
<li>真代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder_Recursion</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,bt-&gt;data);</span><br><span class="line">    PreOrder_Recursion(bt-&gt;leftchild);</span><br><span class="line">    PreOrder_Recursion(bt-&gt;rightchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历-1"><a href="#中序遍历-1" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul>
<li>真代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InOrder_Recursion</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    InOrder_Recursion(bt-&gt;leftchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,bt-&gt;data);</span><br><span class="line">    InOrder_Recursion(bt-&gt;rightchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="后序遍历-1"><a href="#后序遍历-1" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul>
<li>真代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder_Recursion</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    PostOrder_Recursion(bt-&gt;leftchild);</span><br><span class="line">    PostOrder_Recursion(bt-&gt;rightchild);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,bt-&gt;data);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="广度（层次）遍历"><a href="#广度（层次）遍历" class="headerlink" title="广度（层次）遍历"></a>广度（层次）遍历</h3><ul>
<li>真代码</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">LevelOrder</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree p;</span><br><span class="line">    LinkQueue <span class="built_in">queue</span> = SetNullQueue_Link();			<span class="comment">//创建空队列</span></span><br><span class="line">    <span class="keyword">if</span>(bt==<span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    p = bt;</span><br><span class="line">    EnQueue_Link(<span class="built_in">queue</span>,bt);							<span class="comment">//根结点入队</span></span><br><span class="line">    <span class="keyword">while</span>(!IsNullQueue_Link(<span class="built_in">queue</span>))					<span class="comment">//队列不空，循环执行</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = FrontQueue_link(<span class="built_in">queue</span>);					<span class="comment">//取队头</span></span><br><span class="line">        DeQueue_link(<span class="built_in">queue</span>);						<span class="comment">//出队</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;leftchld!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue_link(<span class="built_in">queue</span>.p-&gt;leftchild);		<span class="comment">//左孩子不空，入队</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rightchild!=<span class="literal">NULL</span>)</span><br><span class="line">            EnQueue_link(<span class="built_in">queue</span>,p-&gt;rightchild);		<span class="comment">//右孩子不空，入队</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="（非递归）二叉树的建立于遍历"><a href="#（非递归）二叉树的建立于遍历" class="headerlink" title="（非递归）二叉树的建立于遍历"></a>（非递归）二叉树的建立于遍历</h2><ul>
<li><p>非递归建立二叉树算法思路：</p>
<ol>
<li><p>将二叉树扩充为完全二叉树，输入&#x3D;&#x3D;完全二叉树序列&#x3D;&#x3D;，以<code>#</code>为结束标志，设置计数器<code>count</code>为<code>-1</code>，用来标志结点的序号</p>
</li>
<li><p>如果输入的不是<code>@</code>，则生成一个新的结点<code>s</code>，并对结点的数据域赋值为输入的字符，结点左右指针域为空，结点<code>s</code>入队</p>
<p>如果输入的是<code>@</code>，<code>@</code>也入队，但不生成新的结点</p>
<p><code>count++</code></p>
</li>
<li><p>如果<code>count=0</code>，则结点为根结点，设置二叉树的根<code>bt=s</code></p>
<p>如果<code>count=奇数</code>，则结点为父结点<code>p</code>（队头结点）的左孩子，即<code>p-&gt;leftchild=s</code>；</p>
<p>如果<code>count=偶数</code>，则结点为父结点<code>p</code>（队头结点）的右孩子，即<code>p-&gt;rightchild=s</code>；</p>
<p>队头结点<code>p</code>处理完毕，出队</p>
</li>
</ol>
</li>
<li><p>代码实现：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">BinTree <span class="title function_">CreateBinTree_NRecursion</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkQueue <span class="built_in">queue</span> = SetNullQueue_Link();		<span class="comment">//设置空队列</span></span><br><span class="line">    BinTreeNode *s, *p, *bt;</span><br><span class="line">    <span class="type">char</span> ch;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">-1</span>;</span><br><span class="line">    ch = getchar();</span><br><span class="line">    bt = <span class="literal">NULL</span>;		<span class="comment">//设置二叉树为空</span></span><br><span class="line">    <span class="keyword">while</span>(ch!=<span class="string">&#x27;#&#x27;</span>)	<span class="comment">//假设结点的值为单个字符，以#结束</span></span><br><span class="line">    &#123;</span><br><span class="line">        s = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="keyword">if</span>(ch!=<span class="string">&#x27;@&#x27;</span>)	<span class="comment">//判断读入的点是否为虚结点&#x27;@&#x27;</span></span><br><span class="line">        &#123;</span><br><span class="line">            s = (BinTreeNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(BinTreeNode));		<span class="comment">//申请新结点空间</span></span><br><span class="line">            s-&gt;data = ch;		<span class="comment">//新结点数据域赋值</span></span><br><span class="line">            s-&gt;leftchild = s-&gt;rightchild = <span class="literal">NULL</span>;		<span class="comment">//新结点左右指针域置空</span></span><br><span class="line">        &#125;</span><br><span class="line">        EnQueue_link(<span class="built_in">queue</span>,s);		<span class="comment">//新结点地址或虚结点地址入队</span></span><br><span class="line">        count++;		<span class="comment">//计数器++</span></span><br><span class="line">        <span class="keyword">if</span>(count == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            bt = s;		<span class="comment">//计数器为0，当前结点为根结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = FrontQueue_link;		<span class="comment">//取队头元素</span></span><br><span class="line">            <span class="keyword">if</span>(s!=<span class="literal">NULL</span>&amp;&amp;p!=<span class="literal">NULL</span>)		<span class="comment">//当前结点和双亲结点都不为虚结点</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(count%<span class="number">2</span> == <span class="number">1</span>)		<span class="comment">//count为奇数，新结点为左孩子	</span></span><br><span class="line">                    p-&gt;leftchild = s;</span><br><span class="line">                <span class="keyword">else</span> p-&gt;rightchild = s;		<span class="comment">//count为偶数，新结点为右孩子</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(count % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">            	Dequeue_link(<span class="built_in">queue</span>);		<span class="comment">//两个孩子处理完毕，出队，处理下一个结点</span></span><br><span class="line">        &#125;</span><br><span class="line">        ch = getchar();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> bt;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="先序遍历-2"><a href="#先序遍历-2" class="headerlink" title="先序遍历"></a>先序遍历</h3><ul>
<li>算法思路一：</li>
</ul>
<p>让每个结点都进栈出栈一次，先将根结点压入栈中，如果栈不空，弹出一个元素依次访问其右孩子和左孩子，再重复判断栈是否为空，不空则出栈将其右左孩子入栈，直到栈空为止</p>
<ul>
<li>算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder_NRecursion1</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkStack lstack;</span><br><span class="line">    lstack = SetNullStack_Link();</span><br><span class="line">    BinTreeNode *p;</span><br><span class="line">    Push_link(lstack,bt);				<span class="comment">//根结点入栈</span></span><br><span class="line">    <span class="keyword">while</span>(!IsNullStack_link(lstack))</span><br><span class="line">    &#123;</span><br><span class="line">        p = Top_link(lstack);			<span class="comment">//弹出入栈结点进行判断</span></span><br><span class="line">        Pop_link(lstack);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;rightchild)</span><br><span class="line">            Push_link(lstack,p-&gt;rightchild);		<span class="comment">//右子树不空，进栈</span></span><br><span class="line">        <span class="keyword">if</span>(p-&gt;leftchild)</span><br><span class="line">            Push_link(lstack,p-&gt;leftchild);			<span class="comment">//左子树不空，进栈</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法思路一：</li>
</ul>
<p>右孩子入栈，左孩子直接访问，直到遍历完所有的左孩子，判断栈空，如果不空，弹出，访问右结点，直到栈空</p>
<ul>
<li>算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PreOrder_NRecursion2</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    LinkStack lstack;	<span class="comment">//定义链栈</span></span><br><span class="line">    BinTreeNode *p = bt;</span><br><span class="line">    lstack = SetNullStack_Link();	<span class="comment">//初始化链栈</span></span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Push_link(lstack,bt);</span><br><span class="line">    <span class="keyword">while</span>(!IsNullStack_link(lstack))	<span class="comment">//当栈不空时</span></span><br><span class="line">    &#123;</span><br><span class="line">        p = Top_link(lstack);</span><br><span class="line">        Pop_link(lstack);</span><br><span class="line">        <span class="keyword">while</span>(p)		<span class="comment">//当左结点不空时</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);	<span class="comment">//访问结点</span></span><br><span class="line">            <span class="keyword">if</span>(p-&gt;rightchild)</span><br><span class="line">                Push_link(lstack,p-&gt;rightchild);</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="中序遍历-2"><a href="#中序遍历-2" class="headerlink" title="中序遍历"></a>中序遍历</h3><ul>
<li>算法思路：</li>
</ul>
<p>先让所有左分支的结点入栈，然后倒序访问，每访问一个结点过后访问其右子树，如果右子树有内容，则重复让右子树所有结点入栈，直到右子树为空或者栈为空，遍历完成</p>
<ul>
<li>算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> InOrder)NRecursion1(BinTree bt)</span><br><span class="line">&#123;</span><br><span class="line">    LinkStack lstack;</span><br><span class="line">    lstack = SetNullStack_Link();</span><br><span class="line">    BinTree p;</span><br><span class="line">    p = bt;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    Push_link(lstack,bt);		<span class="comment">//根结点进栈</span></span><br><span class="line">    p = p-&gt;leftchild;		<span class="comment">//访问左子树</span></span><br><span class="line">    <span class="keyword">while</span>(p||!IsNullStack_link(lstack))		<span class="comment">//当p不空或栈为空时跳出循环</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)		<span class="comment">//当p不空</span></span><br><span class="line">        &#123;</span><br><span class="line">            Push_link(lstack, p);	<span class="comment">//左子树结点不断进栈</span></span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p = Top_link(lstack());		<span class="comment">//取栈顶元素访问</span></span><br><span class="line">        Pop_link(lstack);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);		</span><br><span class="line">        p = p-&gt;rightchild;		<span class="comment">//访问结点的右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="后序遍历-2"><a href="#后序遍历-2" class="headerlink" title="后序遍历"></a>后序遍历</h3><ul>
<li>算法思路：</li>
</ul>
<p>&#x3D;&#x3D;访问的第一个结点应该是叶子结点&#x3D;&#x3D;</p>
<p>先让所有的左分支的结点入栈，然后检查右分支，如果右分支不为空则继续检查右分支的左分支，直到一个结点的左右两分支都为空，该结点出栈，访问</p>
<p>如果该结点是父结点的左孩子，则继续进入父结点的右分支检查右分支的左分支</p>
<p>如果该结点是父结点的右孩子，则访问其父结点，退回到上一层</p>
<p>直到叶子结点为空且栈也空</p>
<ul>
<li>算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">PostOrder_NRecursion</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    BinTree p = bt;</span><br><span class="line">    LinkStack lstack;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    lstack = SetNullStack_Link();</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span> || !IsNullStack_link(lstack))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>(p != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            Push_link(lstack,p);</span><br><span class="line">            p = p-&gt;leftchild? p-&gt;leftchild:p-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p = Top_link(lstack);</span><br><span class="line">        Pop_link(lstack);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%c&quot;</span>,p-&gt;data);</span><br><span class="line">        <span class="keyword">if</span>(!IsNullStack_link(lstack)&amp;&amp;(Top_link(lstack)-&gt;leftchild == p))</span><br><span class="line">            p = (Top_link(lstack))-&gt;rightchild;<span class="comment">//如果当前结点是父结点的左子树，进入父结点的右子树</span></span><br><span class="line">        <span class="keyword">else</span> p = <span class="literal">NULL</span>;		<span class="comment">//如果当前结点是父结点的右子树，退回到上一结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="二叉树的其他操作"><a href="#二叉树的其他操作" class="headerlink" title="二叉树的其他操作"></a>二叉树的其他操作</h2><h3 id="统计二叉树叶子结点个数"><a href="#统计二叉树叶子结点个数" class="headerlink" title="统计二叉树叶子结点个数"></a>统计二叉树叶子结点个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CountLeafNode</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">//递归调用结束条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>((bt-&gt;leftchild == <span class="literal">NULL</span>)&amp;&amp;(bt-&gt;rightchild == <span class="literal">NULL</span>))		<span class="comment">//如果是叶子结点返回1</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span>		<span class="comment">//递归遍历左子树和右子树</span></span><br><span class="line">        <span class="keyword">return</span>(CountLeafNode(bt-&gt;leftchild) + CountLeafNode(bt-&gt;rightchild));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统计二叉树总的结点个数"><a href="#统计二叉树总的结点个数" class="headerlink" title="统计二叉树总的结点个数"></a>统计二叉树总的结点个数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CountNode</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;		<span class="comment">//递归调用结束条件</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span>(CountNode(bt-&gt;leftchild) + CountNode(bt-&gt;rightchild) + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="统计二叉树右结点数"><a href="#统计二叉树右结点数" class="headerlink" title="统计二叉树右结点数"></a>统计二叉树右结点数</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CountRightNode</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> num = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(bt-&gt;rightchild!=<span class="literal">NULL</span>)</span><br><span class="line">        num++;</span><br><span class="line">    num += CountRightNode(bt-&gt;leftchild);</span><br><span class="line">    num += CountRightNode(bt-&gt;rightchild);</span><br><span class="line">    <span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="计算二叉树的深度"><a href="#计算二叉树的深度" class="headerlink" title="计算二叉树的深度"></a>计算二叉树的深度</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">CountLevel</span><span class="params">(BinTree bt)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(bt == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> i = CountLevel(bt-&gt;leftchild);</span><br><span class="line">        <span class="type">int</span> j = CountLevel(bt-&gt;rightchild);</span><br><span class="line">        <span class="keyword">return</span> (i&gt;j?i:j) + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查找数据元素"><a href="#查找数据元素" class="headerlink" title="查找数据元素"></a>查找数据元素</h3><blockquote>
<p>有空记得补</p>
</blockquote>
<h2 id="树和森林"><a href="#树和森林" class="headerlink" title="树和森林"></a>树和森林</h2><h3 id="树、森林转为二叉树"><a href="#树、森林转为二叉树" class="headerlink" title="树、森林转为二叉树"></a>树、森林转为二叉树</h3><ul>
<li>加线：在所有相邻的<code>兄弟结点</code>之间连线</li>
<li>抹线：对每个非终端结点，只<code>保留</code>它到其<code>最左子女</code>的连线，<code>删去</code>与<code>其他子女</code>的连线</li>
<li>调整：以<code>根结点</code>为轴心，将整颗树进行<code>旋转</code></li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201215141452.png"></p>
<h3 id="二叉树转换为树或森林"><a href="#二叉树转换为树或森林" class="headerlink" title="二叉树转换为树或森林"></a>二叉树转换为树或森林</h3><ul>
<li>加线：若p结点时双亲结点的左孩子，则将p的右孩子，右孩子的右孩子，…，沿分支找到所有的右孩子，都与p的双亲用线相连</li>
<li>抹线：抹掉原二叉树中双亲与右孩子之间的连线</li>
<li>调整：将结点按层次排列，形成树结构</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201215141953.png"></p>
<h2 id="哈夫曼树"><a href="#哈夫曼树" class="headerlink" title="哈夫曼树"></a>哈夫曼树</h2><p><code>WPL</code>：扩充二叉树的带权的外部路径长度</p>
<p>​                                                                                       $\displaystyle \sum^{m}_{i \to 0}{w_i \times l_i}$</p>
<p><strong>w<del>i</del> <strong>是第 i 个外部结点的权值， <strong>l<del>i</del></strong> 是从根到第 i 个外部结点的路径长度，</strong>m</strong>为外部结点的个数</p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201215142542.png"></p>
<h3 id="哈夫曼算法"><a href="#哈夫曼算法" class="headerlink" title="哈夫曼算法"></a>哈夫曼算法</h3><ul>
<li>算法思路：</li>
</ul>
<ol>
<li>由给定的 m 个权值 <strong>{w<del>1</del>，w<del>2</del>，…，w<del>m</del>}</strong> 构造成 m 颗二叉树集 F &#x3D; {T<del>1</del>，T<del>2</del>，…，T<del>m</del> }，其中每一棵二叉树 T<del>i</del> 中只有一个带权为 w<del>i</del> 的根结点，且根结点的权值为 <strong>w<del>i</del></strong></li>
<li>在 F 中选取<code>两棵权值最小的</code>树作为左右子树构造一棵新的二叉树，且<code>新二叉树的根结点的权值</code>为其左右子树根结点<code>权值之和</code></li>
<li>在F中<code>删除</code>这两棵树，同时将<code>新得到的二叉树加入 F 中</code></li>
<li>重复 2. 和 3. ，<code>直到 F 中只含一棵树为止</code></li>
</ol>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201215144059.png"></p>
<ul>
<li>类型定义：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">HuffNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> weight;	<span class="comment">//权值</span></span><br><span class="line">    <span class="type">int</span> parent,leftchild,rightchild;	<span class="comment">//父结点与左右孩子</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffNode</span> *<span class="title">HtNode</span>;</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">HuffTreeNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> n;		<span class="comment">//哈夫曼树的叶子结点个数</span></span><br><span class="line">    <span class="type">int</span> root;	<span class="comment">//哈夫曼树的树根</span></span><br><span class="line">    HtNode ht;	<span class="comment">//指向哈夫曼树的指针</span></span><br><span class="line">&#125;*HuffTree;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">HuffTree <span class="title function_">CreateHuffTree</span><span class="params">(<span class="type">int</span> n,<span class="type">int</span> *w)</span></span><br><span class="line">&#123;</span><br><span class="line">    HuffTree pht;</span><br><span class="line">    <span class="type">int</span> i, j, x1, x2, min1, min2;</span><br><span class="line">    pht = (HuffTree)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HuffNode)*(<span class="number">2</span>*n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">if</span>(pht == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Oui of space!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pht;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//为哈夫曼树申请 2n-1 个空间</span></span><br><span class="line">    pht-&gt;ht = (HtNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> HuffNode)*(<span class="number">2</span>*n<span class="number">-1</span>));</span><br><span class="line">    <span class="keyword">if</span>(pht-&gt;ht == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Oui of space!\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> pht;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//初始化哈夫曼树</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>;i&lt;<span class="number">2</span>*n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pht-&gt;ht[i].leftchild = <span class="number">-1</span>;		<span class="comment">//初始化叶结点的左孩子</span></span><br><span class="line">        pht-&gt;ht[i].rightchild = <span class="number">-1</span>;		<span class="comment">//初始化叶结点的右孩子</span></span><br><span class="line">        pht-&gt;ht[i].parent = <span class="number">-1</span>;			<span class="comment">//初始化叶结点的父亲</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;n)</span><br><span class="line">            pht-&gt;ht[i].weight = w[i];</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            pht-&gt;ht[i].weight = <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min1 = MAX;	<span class="comment">//min1代表最小值</span></span><br><span class="line">        min2 = MAX;	<span class="comment">//min2代表次小值</span></span><br><span class="line">        x1 = <span class="number">-1</span>;	<span class="comment">//最小值下标</span></span><br><span class="line">        x2 = <span class="number">-1</span>;	<span class="comment">//次小值下标</span></span><br><span class="line">        <span class="comment">//找到最小值下标 x1 并把最小值赋给 min1</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;n+<span class="number">1</span>;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(pht-&gt;ht[j].weight &lt; min1&amp;&amp;pht-&gt;ht[j].parent == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                min2 = min1;</span><br><span class="line">                x2 = x1;</span><br><span class="line">                min1 = pht-&gt;ht[j].weight;</span><br><span class="line">                x1 = j;</span><br><span class="line">            &#125;</span><br><span class="line">         <span class="comment">//找到次小值下标x2并把次小值赋给min2</span></span><br><span class="line">        	<span class="keyword">else</span> <span class="keyword">if</span>(pht-&gt;ht[j].weight &lt; min2&amp;&amp;pht-&gt;ht[j].parent == <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                min2 = pht-&gt;ht[j].weight;</span><br><span class="line">                x2 = j;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">       	<span class="comment">//构建 x1，x2 的父结点</span></span><br><span class="line">        pht-&gt;ht[x1].parent = n+<span class="number">1</span>;	<span class="comment">//x1父结点下标</span></span><br><span class="line">        pht-&gt;ht[x2].parent = n+<span class="number">1</span>;	<span class="comment">//x2父结点下标</span></span><br><span class="line">        pht-&gt;ht[n + i].weight = min1 + min2;	<span class="comment">//父结点的权值为极小值加次小值</span></span><br><span class="line">        pht-&gt;ht[n + i].leftchild = x1;	<span class="comment">//父结点的左孩子为x1</span></span><br><span class="line">        pht-&gt;ht[n + i].rightchild = x2;	<span class="comment">//父结点的右孩子为x2</span></span><br><span class="line">    &#125;</span><br><span class="line">    pht-&gt;root = <span class="number">2</span>*n<span class="number">-2</span>;		<span class="comment">//哈夫曼树根结点位置</span></span><br><span class="line">    pht-&gt;n = n;</span><br><span class="line">    <span class="keyword">return</span> pht;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="哈夫曼编码（最优前缀编码）"><a href="#哈夫曼编码（最优前缀编码）" class="headerlink" title="哈夫曼编码（最优前缀编码）"></a>哈夫曼编码（最优前缀编码）</h3><ul>
<li>编码长度最短</li>
<li>字符集中任一字符的编码都<code>不是</code>其他字符的编码的<code>前缀</code></li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201215233402.png"></p>
<h1 id="第四章-搜索树"><a href="#第四章-搜索树" class="headerlink" title="第四章 搜索树"></a>第四章 搜索树</h1><h2 id="二分判定查找树"><a href="#二分判定查找树" class="headerlink" title="二分判定查找树"></a>二分判定查找树</h2><ul>
<li>平均检索长度：ASL</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201216004321.png"></p>
<ul>
<li>二分查找判定树</li>
</ul>
<p><code>查找成功</code>：查找二分查找判定树中已有的结点，路径为根结点——&gt;该结点，经过结点个数为比较次数</p>
<p><code>查找失败</code>：走的是一条根结点——&gt;扩充二叉树的外部结点的路径</p>
<h2 id="二分排序树（BST）的基本概念"><a href="#二分排序树（BST）的基本概念" class="headerlink" title="二分排序树（BST）的基本概念"></a>二分排序树（BST）的基本概念</h2><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201216012844.png"></p>
<ul>
<li>&#x3D;&#x3D;对称遍历有序性&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;二分查找方便&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;插入的都是叶子结点&#x3D;&#x3D;</li>
<li>&#x3D;&#x3D;删除不需要移动结点&#x3D;&#x3D;</li>
</ul>
<h2 id="二分排序树的查找"><a href="#二分排序树的查找" class="headerlink" title="二分排序树的查找"></a>二分排序树的查找</h2><ul>
<li>返回NULL查找成功，否则查找失败</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BSTreeNode <span class="title function_">BSTearch</span><span class="params">(BinSearTree bt,DataType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTreeNode p,parent;</span><br><span class="line">    p = bt;</span><br><span class="line">    parent = p;	<span class="comment">//记录待插入结点的父结点</span></span><br><span class="line">    <span class="keyword">while</span>(p)</span><br><span class="line">    &#123;</span><br><span class="line">        parent = p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;exist this key\n&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &gt; key)</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> parent;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分排序树的插入"><a href="#二分排序树的插入" class="headerlink" title="二分排序树的插入"></a>二分排序树的插入</h2><ul>
<li>先查询，建立新结点，判断原二叉排序树是否为空，为空则为根结点，否则进入判断，新结点大于父结点插入右子树，新结点小于父结点插入左子树</li>
<li>插入成功返回1，失败返回0</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTInsert</span><span class="params">(BinSearTree bt,DataType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    BSTreeNode p,temp;</span><br><span class="line">    temp = BSTSearch(bt,key);	<span class="comment">//调用查找算法，在上面</span></span><br><span class="line">    <span class="keyword">if</span>(temp == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;exist this key\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p = (BSTreeNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="keyword">struct</span> BinSearTreeNode));	<span class="comment">//申请结点</span></span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;malloc 失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    p-&gt;data = key;</span><br><span class="line">    p-&gt;leftchild = p-&gt;rightchild = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span>(key &lt; temp-&gt;data)</span><br><span class="line">        temp-&gt;leftchild = p;	<span class="comment">//作为左孩子插入</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        temp-&gt;rightchild = p;	<span class="comment">//作为右孩子插入</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="二分排序树的删除"><a href="#二分排序树的删除" class="headerlink" title="二分排序树的删除"></a>二分排序树的删除</h2><ul>
<li><p>如果待删除结点 p 的左子树为空，则只要令右子树的根结点直接代替 p 即可</p>
</li>
<li><p>如果待删除结点 p 的左子树不为空</p>
</li>
<li><ul>
<li><p>方法一：</p>
</li>
<li><p>需要遍历 p 的左子树，找到最大的结点 maxpl ，删除 maxpl，再用 maxpl 代替 p 原来的位置</p>
</li>
<li><ul>
<li>如果 maxpl 有左分支，用其左分支代替原来 maxpl 的位置， maxpl 依旧去代替 p 结点的位置</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201216015910.png"></p>
<ul>
<li>删除算法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTDelete1</span><span class="params">(BinSearTree *bt,DataType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// parent 记录 p 的父结点，maxpl 记录 p 的左子树中最大的结点</span></span><br><span class="line">    BSTreeNode parent ,p,maxpl;</span><br><span class="line">    p = *bt;</span><br><span class="line">    parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        parent = p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &gt; key)</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not exist\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;leftchild == <span class="literal">NULL</span>)	<span class="comment">//只有右子树的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>)		<span class="comment">//判断是不是删了根结点</span></span><br><span class="line">            *bt = p-&gt;rightchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(parent-&gt;leftchild == p)		<span class="comment">//如果p是父结点的左孩子</span></span><br><span class="line">            parent-&gt;leftchild = p-&gt;rightchild;</span><br><span class="line">        <span class="keyword">else</span>								<span class="comment">//如果p是父结点的右孩子</span></span><br><span class="line">            parent-&gt;rightchild = p-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;leftchild!=<span class="literal">NULL</span>)	<span class="comment">//p有左子树和右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        BSTreeNOde parentp;	<span class="comment">//parentp记录maxpl的父结点</span></span><br><span class="line">        parentp = p;</span><br><span class="line">        maxpl = p-&gt;leftchild;</span><br><span class="line">        <span class="keyword">while</span>(maxpl-&gt;rightchild != <span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            parentp = maxpl;</span><br><span class="line">            maxpl = maxpl-&gt;rightchild;</span><br><span class="line">        &#125;</span><br><span class="line">        p-&gt;data = maxpl-&gt;data;	<span class="comment">//修改 p 的数据域为 maxpl 的数据域</span></span><br><span class="line">        <span class="keyword">if</span>(parentp == p)		<span class="comment">//如果maxpl父结点是p</span></span><br><span class="line">            p-&gt;leftchile = maxpl-&gt;leftchild;	<span class="comment">//修改p的左指针，置空</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            parentp-&gt;rightchild = maxpl-&gt;leftchild;	<span class="comment">//修改父结点的左指针，置空</span></span><br><span class="line">        p = maxpl;	<span class="comment">//更新 p 指针为 maxpl 结点以便删除</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><ul>
<li>方法二：</li>
<li>直接让 p 的左子树根结点代替 p ，p 的 右子树接到 maxpl 的右子树</li>
</ul>
</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201216023303.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">BSTDelete2</span><span class="params">(BinSearTree *bt,DataType key)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// parent 记录 p 的父结点，maxpl 记录 p 的左子树中最大的结点</span></span><br><span class="line">    BSTreeNode parent ,p,maxpl;</span><br><span class="line">    p = *bt;</span><br><span class="line">    parent = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data == key)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        parent = p;</span><br><span class="line">        <span class="keyword">if</span>(p-&gt;data &gt; key)</span><br><span class="line">            p = p-&gt;leftchild;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            p = p-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;not exist\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;leftchild == <span class="literal">NULL</span>)	<span class="comment">//只有右子树的情况</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>)		<span class="comment">//判断是不是删了根结点</span></span><br><span class="line">            *bt = p-&gt;rightchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(parent-&gt;leftchild == p)		<span class="comment">//如果p是父结点的左孩子</span></span><br><span class="line">            parent-&gt;leftchild = p-&gt;rightchild;</span><br><span class="line">        <span class="keyword">else</span>								<span class="comment">//如果p是父结点的右孩子</span></span><br><span class="line">            parent-&gt;rightchild = p-&gt;rightchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(p-&gt;leftchild!=<span class="literal">NULL</span>)	<span class="comment">//p有左子树和右子树</span></span><br><span class="line">    &#123;</span><br><span class="line">        maxpl = p-&gt;leftchild;</span><br><span class="line">        <span class="keyword">while</span>(maxpl-&gt;rightchild!=<span class="literal">NULL</span>)</span><br><span class="line">            maxpl = maxpl-&gt;rightchild;</span><br><span class="line">        maxpl-&gt;rightchild = p-&gt;rightchild;	<span class="comment">//把p的右分支全部接到 maxpl 的右分支，因为都比 maxpl 大</span></span><br><span class="line">        <span class="keyword">if</span>(parent == <span class="literal">NULL</span>)	<span class="comment">//判断是不是删了根结点</span></span><br><span class="line">            *bt = p-&gt;leftchild;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(parent-&gt;leftchild == p)		<span class="comment">//如果p是父结点的左孩子</span></span><br><span class="line">            parent-&gt;leftchild = p-&gt;leftchild;</span><br><span class="line">        <span class="keyword">else</span>								<span class="comment">//如果p是父结点的右孩子</span></span><br><span class="line">            parent-&gt;rightchild = p-&gt;leftchild;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="平衡二叉排序树（AVL）的概念"><a href="#平衡二叉排序树（AVL）的概念" class="headerlink" title="平衡二叉排序树（AVL）的概念"></a>平衡二叉排序树（AVL）的概念</h2><ul>
<li>可以是空树</li>
<li>&#x3D;&#x3D;左右子树均为平衡二叉排序树，且左右子树深度之差绝对值不超过1&#x3D;&#x3D;</li>
<li>结点的&#x3D;&#x3D;平衡因子BF：结点的左子树深度 - 右子树深度&#x3D;&#x3D;</li>
</ul>
<h3 id="AVL树"><a href="#AVL树" class="headerlink" title="AVL树"></a>AVL树</h3><ul>
<li>&#x3D;&#x3D;平衡因子BF只能是 -1，0，1 的二叉树&#x3D;&#x3D;</li>
</ul>
<h2 id="AVL树的四种调整"><a href="#AVL树的四种调整" class="headerlink" title="AVL树的四种调整"></a>AVL树的四种调整</h2><blockquote>
<p>以后有空补上</p>
</blockquote>
<h1 id="第五章-图"><a href="#第五章-图" class="headerlink" title="第五章 图"></a>第五章 图</h1><h2 id="图的基本概念"><a href="#图的基本概念" class="headerlink" title="图的基本概念"></a>图的基本概念</h2><ul>
<li><p>度：无向图中顶点 v 的度是关联与该顶点的边的数目，记为 D(v)</p>
</li>
<li><p>入度：有向图中以顶点 v 为终点的边的数目称为 v 的入度，记为 ID(v)</p>
</li>
<li><p>出度：有向图中以顶点 v 为始点的边的数目称为 v 的出度，记为 OD(v)</p>
</li>
<li><p>&#x3D;&#x3D;有向图中顶点 v 的度定义为该顶点的入度和出度之和&#x3D;&#x3D;</p>
</li>
<li><p>&#x3D;&#x3D;无论是有向图还是无向图，顶点数 n 和边数 e 和度数之间的关系为&#x3D;&#x3D;</p>
</li>
</ul>
<p>​                                                                                     $\displaystyle \sum^{n}_{i \to 1}{D(v_i) &#x2F; 2}$</p>
<p>你开始小心翼翼的避开我，像极了曾经的自己，而我能做的只是远远的望着你，其实我也很想主动靠近你，但最后还是把耐心都给了你，时间过了很久你还是不为所动，好像根本就没有意识到我的存在，我开始有些失落，想着是否能够离你近一点，可你那过分的敏感，让我愣在原地有些不知所措，脑海里出现过很多不同的场景，可能是压抑了太久，我觉得自己已经很卑微了，但对于你来说，不知道这是错过还是解脱。但其实说来也好笑，自己又何尝不是和你一样呢。你还是不肯面对我，即使你已经走到了我的面前，你真的已经缺席了太多我需要你的时刻，你曾经那模糊的好感，让我心动很久，可现在，我已经没有再等下去的勇气了，我的心，已经开始乱了。不甘心于舍不得，只会让我们的距离越来越大，原来我始终都是个局外人，这绵延的城市应有尽有，却唯独没有你，也没有尽头，只有我的存在，始终都是违和的，有些事到此为止，就是最好的收场，不是想通了，是算了，就连你唯一一次朝着我走来，也只不过是给了我一场空欢喜，若不是失望到极致，又怎会，两眼无悲喜，你给我的遗憾虽然很多很多，但最后离开的你，也陪我度过了很久很久</p>
<h2 id="图的存储表示"><a href="#图的存储表示" class="headerlink" title="图的存储表示"></a>图的存储表示</h2><h3 id="邻接矩阵表示法"><a href="#邻接矩阵表示法" class="headerlink" title="邻接矩阵表示法"></a>邻接矩阵表示法</h3><p>举例：</p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201216201328.png"></p>
<ul>
<li>邻接矩阵图的类型定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GRAPHMATRIX_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> size;		<span class="comment">//图中结点的个数</span></span><br><span class="line">    <span class="type">int</span> **graph;	<span class="comment">//二维数组保存图</span></span><br><span class="line">&#125;GraphMatrix;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化图（邻接矩阵）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">GraphMatrix* <span class="title function_">InitGraph</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    GraphMatrix* graphMatrix = (GraphMatrix*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphMatrix));</span><br><span class="line">    graphMatrix-&gt;size = num;	<span class="comment">//图中结点个数</span></span><br><span class="line">    <span class="comment">//给图分配空间</span></span><br><span class="line">    graphMatrix-&gt;graph = (<span class="type">int</span>**)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>*)*graphMatrix-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(i=o;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">        graphMatrix-&gt;graph[i]=(<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*graphMatrix-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">            graphMatrix-&gt;graph[i][j] = INT_MAX;	<span class="comment">//初始设置所有顶点不邻接</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> graphMatrix;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>为什么要申请两次空间？</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201216230949.png"></p>
<ul>
<li>输入邻接矩阵图算法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ReadGraph</span><span class="params">(GraphMatrix* graphMatrix)</span>	<span class="comment">//输入边信息构建图</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> vex1,vex2,weight;</span><br><span class="line">    <span class="comment">//输入方式是点 点 权值，权值为0，则输入结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入，输入方式为点 点 权值，权值为0，则输入结束\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d%d%d&quot;</span>,&amp;vex1,&amp;vex2,&amp;weight);</span><br><span class="line">    <span class="keyword">while</span>(weight!=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        graphMatrix-&gt;graph[vex1][vex2] = weight;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d%d%d&quot;</span>,&amp;vex1,&amp;vex2,&amp;weight);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="邻接表表示法"><a href="#邻接表表示法" class="headerlink" title="邻接表表示法"></a>邻接表表示法</h3><p>举例：</p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201216202227.png"></p>
<ul>
<li>容易确定图的顶点数和判断一个顶点与哪几个顶点是否有边相连</li>
<li>容易确定图的顶点的度，即顶点对应顺序表的链表链接的结点个数</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201216204631.png"></p>
<ul>
<li>邻接表图的类型定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GRAPHLISTNODE_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> nodeno;	<span class="comment">//图中结点编号</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">GRAPHLISTNODE_STRU</span>* <span class="title">next</span>;</span>	<span class="comment">//指向下一个结点的指针</span></span><br><span class="line">&#125;GraphListNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">GRAPHLIST_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> size;	<span class="comment">//图中结点个数</span></span><br><span class="line">    GraphListNode* graphListArray;	<span class="comment">//图的邻接表，用二维数组表示</span></span><br><span class="line">&#125;GraphList;</span><br></pre></td></tr></table></figure>

<ul>
<li>初始化图（邻接表）</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">GraphList* <span class="title function_">IniGraph</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    GraphList *grahList = (GraphList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphList));</span><br><span class="line">    grapList-&gt;size = num;</span><br><span class="line">    graphList-&gt;graphListArray = (GraphListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphListNode)*num);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        graphList-&gt;graphListArray[i].next = <span class="literal">NULL</span>;</span><br><span class="line">        graphList-&gt;graphListArray[i].nodeno = i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> grapList;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>输入邻接矩阵图算法：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ReadGraph</span><span class="params">(GraphList* graphList)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> vex1,vex2;</span><br><span class="line">    GraphListNode *tempNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">//输入方式为点 点，点为-1，则输入结束</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;请输入，输入方式为点 点，点为-1，则输入结束\n&quot;</span>);</span><br><span class="line">    scanf_s(<span class="string">&quot;%d%d&quot;</span>,&amp;vex1,&amp;vex2);</span><br><span class="line">    <span class="keyword">while</span>(vex1&gt;=<span class="number">0</span> &amp;&amp; vex2&gt;=<span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        tempNode = (GraphListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(GraphListNode));</span><br><span class="line">        tempNode-&gt;nodeno = vex2;</span><br><span class="line">        tempNode-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        <span class="comment">//头插法插入结点</span></span><br><span class="line">        tempNode-&gt;next = graphList-&gt;graphListArray[vex1].next;</span><br><span class="line">        graphList-&gt;graphListArray[vex1].next = tempNode;</span><br><span class="line">        scanf_s(<span class="string">&quot;%d%d&quot;</span>,&amp;vex1,&amp;vex2);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="邻接多重表表示法"><a href="#邻接多重表表示法" class="headerlink" title="邻接多重表表示法"></a>邻接多重表表示法</h3><h3 id="图的十字链表"><a href="#图的十字链表" class="headerlink" title="图的十字链表"></a>图的十字链表</h3><blockquote>
<p>以后有空补上</p>
</blockquote>
<h2 id="图的周游"><a href="#图的周游" class="headerlink" title="图的周游"></a>图的周游</h2><ul>
<li>遍历每个顶点，不重复</li>
</ul>
<h3 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h3><ul>
<li>指定顶点<code>v</code>出发，先访问顶点<code>v</code>，并<code>将其标记</code></li>
<li>如果存在与<code>v</code>邻接顶点没被访问过，则选择其中的一个<code>w</code>出发进行<code>DFS(w)</code></li>
<li>否则，返回</li>
<li><code>如果图中有未被访问的顶点，则从另一未被访问的顶点出发重复上述过程，直到遍历全部顶点</code></li>
<li>邻接矩阵 DFS 算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFSGraphMatrix</span><span class="params">(GraphMatrix * graphMatrix)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;	<span class="comment">//用于记录图中结点哪些被访问了</span></span><br><span class="line">    <span class="type">int</span> *visited = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* graphMatrix-&gt;size);</span><br><span class="line">    <span class="comment">//初始化所有点都未被访问</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(graphMatrix, visite, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphMatrix* graphMatrix,<span class="type">int</span> *visited,<span class="type">int</span> source)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    visited[source] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(graphMatrix-&gt;graph[source][j] != INT_MAX &amp;&amp; !visited[j])</span><br><span class="line">            DFS(graphMatrix,visited,j);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接表 DFS 算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">DFSGraphMatrix</span><span class="params">(GraphList * graphList)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;	<span class="comment">//用于记录图中结点哪些被访问了</span></span><br><span class="line">    <span class="type">int</span> *visited = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* graphList-&gt;size);</span><br><span class="line">    <span class="comment">//初始化所有点都未被访问</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(graphList, visite, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">DFS</span><span class="params">(GraphLIst* graphList, <span class="type">int</span>* visited,<span class="type">int</span> source)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    GraphList弄得*tempnode = <span class="literal">NULL</span>;</span><br><span class="line">    visited[source] = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,source);</span><br><span class="line">    tempNode = graphList-&gt;graphListArray[source].next;</span><br><span class="line">    <span class="keyword">while</span>(tempNode != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[tempNode-&gt;nodeno])</span><br><span class="line">            DFS(graphList,visited,tempNode-&gt;nodeno);</span><br><span class="line">        tempNode = tempNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h3><ul>
<li>指定顶点<code>v</code>出发，先访问顶点<code>v</code>，并<code>将其标记</code></li>
<li>依次访问<code>v</code>的所有相邻结点</li>
<li>再依次访问与相邻结点邻接的所有没被访问过的顶点</li>
<li>直到所有已访问顶点的相邻结点都被访问过为止</li>
<li><code>如果图中有未被访问的顶点，则从另一未被访问的顶点出发重复上述过程，直到遍历全部顶点</code></li>
<li>邻接矩阵 BFS 算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFSGraphMatrix</span><span class="params">(GraphMatrix * graphList)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;	<span class="comment">//用于记录图中结点哪些被访问了</span></span><br><span class="line">    <span class="type">int</span> *visited = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* graphList-&gt;size);</span><br><span class="line">    <span class="comment">//初始化所有点都未被访问</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            BFS(graphList, visite, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GraphMatrix* graphMatrix,<span class="type">int</span>*visited,<span class="type">int</span> source)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> j,tempVex;</span><br><span class="line">    LinkQueue waitingQueue = <span class="literal">NULL</span>;</span><br><span class="line">    waitingQueue = SetNullQueue_Link();</span><br><span class="line">	<span class="keyword">if</span>(!visited[i])	<span class="comment">//如果没被访问过</span></span><br><span class="line">    &#123;</span><br><span class="line">        visited[i] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,i);</span><br><span class="line">        EnQueue_link(waitingQueue,i);	<span class="comment">//将刚访问结点放入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!IsNullQueue_Link(waitingQueue))</span><br><span class="line">        &#123;</span><br><span class="line">            tempVex = FrontQueue_link(waitingQueue);</span><br><span class="line">            DeQueue_link(waitingQueue);</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//如果其他顶点与当前顶点存在边且未访问过</span></span><br><span class="line">                <span class="keyword">if</span>(graphMatrix-&gt;graph[tempVex][j] != INT_MAX &amp;&amp; !visited[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[j] = source;	<span class="comment">//标记</span></span><br><span class="line">                    EnQueue_link(waitingQueue,j);	<span class="comment">//入队</span></span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,j);	<span class="comment">//输出</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>邻接表 BFS 算法实现</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BFSGraphMatrix</span><span class="params">(GraphList * graphList)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;	<span class="comment">//用于记录图中结点哪些被访问了</span></span><br><span class="line">    <span class="type">int</span> *visited = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)* graphList-&gt;size);</span><br><span class="line">    <span class="comment">//初始化所有点都未被访问</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)</span><br><span class="line">        visited[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">            DFS(graphList, visite, i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">BFS</span><span class="params">(GraphList* graphList,<span class="type">int</span>* visited,<span class="type">int</span> source)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> tempVex;</span><br><span class="line">    GraphListNode *tempNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">queue</span>&lt;<span class="type">int</span>&gt; waitingQueue;	<span class="comment">//广度优先遍历使用的队列是c++的STL中的queue</span></span><br><span class="line">    <span class="keyword">if</span>(!visited[source])</span><br><span class="line">    &#123;</span><br><span class="line">        visited[source] = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,source);</span><br><span class="line">        waitingQueue.push(source);	<span class="comment">//刚刚访问结点放入队列</span></span><br><span class="line">        <span class="keyword">while</span>(!waitingQueue.empty())</span><br><span class="line">        &#123;</span><br><span class="line">            tempVex = waitingQueue.front();</span><br><span class="line">            waitingQueue.pop();</span><br><span class="line">            tempNode = graphList-&gt;graphListArray[tempVex].next;</span><br><span class="line">            <span class="keyword">while</span>(tempNode != <span class="literal">NULL</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!visited[tempNode-&gt;nodeno])</span><br><span class="line">                &#123;</span><br><span class="line">                    visited[tempNode-&gt;nodeno] = <span class="number">1</span>;</span><br><span class="line">                    waitingQueue.push(tempNode-&gt;nodeno);</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,tempNode-&gt;nodeno);</span><br><span class="line">                &#125;</span><br><span class="line">                tempNode = tempNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="最小生成树（MST）"><a href="#最小生成树（MST）" class="headerlink" title="最小生成树（MST）"></a>最小生成树（MST）</h2><h3 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h3><ul>
<li><p>算法思路：每次选择一条权值最小的边及其相应的顶点加入最小生成树，顶点不能重复选用，直到最小生成树中有 <code>n-1</code> 条边为止</p>
</li>
<li><p><code>component[j]</code>用来记录已加入最小生成树的顶点 <code>j</code>，初始化<code>component[j] = 0</code>，当顶点<code>j</code>加入最小生成树后，设置<code>component[j] = 1</code></p>
</li>
<li><p><code>distance[j]</code>用来记录代价最小的边的权值，初始化<code>distance[j] = garphMatrix-&gt;graph[0][j]</code></p>
</li>
<li><p><code>neighbor[j]</code>用来记录代价最小的边对应的顶点，初始化<code>neighbor[j] = 0</code></p>
</li>
<li><p>算法实现：</p>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">GraphMatrix* <span class="title function_">prim</span><span class="params">(GraphMatrix *graphMatrix,<span class="type">int</span> source)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> *component = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(graphMatrix-&gt;size));		<span class="comment">//新点集合</span></span><br><span class="line">    <span class="type">int</span> *diftance = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(graphMatrix-&gt;size));	<span class="comment">//距离</span></span><br><span class="line">    <span class="comment">//邻居，例如 neighbor[j] = 1 表示 j 的邻居是 1</span></span><br><span class="line">    <span class="type">int</span> *neighbor = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(graphMatrix-&gt;size));</span><br><span class="line">    GraphMatrix *tree = IniGraph(graphMatrix-&gt;size);	<span class="comment">//存放结果的图</span></span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">    &#123;</span><br><span class="line">        component[j] = <span class="number">0</span>;</span><br><span class="line">        distance[j] = graphMatrix-&gt;graph[source][j];</span><br><span class="line">        neighbor[j] = source;</span><br><span class="line">    &#125;<span class="comment">//end 9</span></span><br><span class="line">    component[source] = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> v;</span><br><span class="line">        <span class="type">int</span> min = MAX;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;graphMatrix-&gt;size;j++)	<span class="comment">//选择不是新点集合中的距离新点集合最短的那个点</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>（!component[j] &amp;&amp; (distance[j]&lt;min))</span><br><span class="line">            &#123;</span><br><span class="line">                v = j;</span><br><span class="line">                min = distance[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end 20</span></span><br><span class="line">        <span class="keyword">if</span>(min&lt;MAX)</span><br><span class="line">        &#123;</span><br><span class="line">            component[v] = <span class="number">1</span>;</span><br><span class="line">            tree-&gt;graph[v][neighbor[v]] = distance[v];</span><br><span class="line">            tree-&gt;graph[neighbor[v]][v] = distance[v];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(!component[j] &amp;&amp; (graphMatrix-&gt;graph[v][j]&lt;distance[j]))</span><br><span class="line">                &#123;</span><br><span class="line">                    distance[j] = graphMatrix-&gt;graph[v][j];</span><br><span class="line">                    neighbor[j] = v;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="comment">//end 34</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">    &#125;<span class="comment">//end 16</span></span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Kruskai算法"><a href="#Kruskai算法" class="headerlink" title="Kruskai算法"></a>Kruskai算法</h3><ul>
<li>算法思路：先把所有顶点加入最小生成树，然后选择合适的边构建最小生成树，边的权值最小且两个点要属于两个不同的连通分量，直到最小生成树中有 <code>n-1 </code>条边为止</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">EDGE_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> begin;	<span class="comment">//边的起点</span></span><br><span class="line">    <span class="type">int</span> end;	<span class="comment">//边的终点</span></span><br><span class="line">    <span class="type">int</span> weight; <span class="comment">//边的权值</span></span><br><span class="line">&#125;Edge;</span><br><span class="line">GraphMatrix* <span class="title function_">kruskal</span><span class="params">(GraphMatrix *graphMatrix)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,k;</span><br><span class="line">    <span class="type">int</span> edgeNum = <span class="number">0</span>;</span><br><span class="line">    Edge *edge = <span class="literal">NULL</span>;</span><br><span class="line">    Edge tempEdge;	<span class="comment">//给边排序时的临时变量</span></span><br><span class="line">    <span class="type">int</span> pos;	<span class="comment">//记录添加到哪条边</span></span><br><span class="line">    <span class="type">int</span> *group;	<span class="comment">//记录点是否属于同一连通分量</span></span><br><span class="line">    <span class="type">int</span> changeGroup;	<span class="comment">//记录要变化的连通值</span></span><br><span class="line">    GraphMatrix * tree = IniGraph(graphMatrix-&gt;size);	<span class="comment">//存放结果的图</span></span><br><span class="line">    group = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*graphMatrix-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphMatrix-&gt;size;i++)	<span class="comment">//初始化，点之间不连通</span></span><br><span class="line">        group[i] = i;</span><br><span class="line">    <span class="comment">//分析有多少条边</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(graphMatrix-&gt;graph[i][j]&lt;INT_MAX)</span><br><span class="line">                edgeNum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//根据刚计算出来的边的数量分派空间</span></span><br><span class="line">    edge = (Edge*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(Edge)*edgeNum);</span><br><span class="line">    k = <span class="number">0</span>;	<span class="comment">//给边赋值的时候用</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(graphMatrix-&gt;graph[i][j]&lt;INT_MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                edge[k].begin = i;</span><br><span class="line">                edge[k].end = j;</span><br><span class="line">                edge[k].weight = graphMatrix-&gt;graph[i][j];</span><br><span class="line">                k++</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;edgeNum;i++)	<span class="comment">//根据边权值进行排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(j=i+<span class="number">1</span>;j&lt;edgeNum;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(edge[i].weight&gt;edge[j].weight)</span><br><span class="line">            &#123;</span><br><span class="line">                tempEdge = edge[i];</span><br><span class="line">                edge[i] = edge[j];</span><br><span class="line">                edge[j] = tempEdge;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//每次从边数组中取出最小的一条边，判断是否能添加到最小生成树中</span></span><br><span class="line">    <span class="comment">//边数组已排好序</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;edgeNum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//只添加终点和七点属于两个不同连通分量的边</span></span><br><span class="line">        <span class="keyword">if</span>(group[edge[i].begin]!=group[edge[i].end])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//添加到树中</span></span><br><span class="line">            tree-&gt;graph[edge[i].begin][edge[i].end] = edge[i].weight;</span><br><span class="line">            tree-&gt;graph[edge[i].end][edge[i].begin] = edge[i].weight;</span><br><span class="line">            <span class="comment">//更新所有跟终点属于同一连通分量的点的连通性</span></span><br><span class="line">            changeGroup = group[edge[i].end];</span><br><span class="line">            <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;edgeNum;j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(group[j] == changeGroup)</span><br><span class="line">                    group[j] = group[edge[i].begin];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tree;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="Dijstra算法"><a href="#Dijstra算法" class="headerlink" title="Dijstra算法"></a>Dijstra算法</h2><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201217053107.png"></p>
<ul>
<li>算法实现：</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>* <span class="title function_">dijkstra</span><span class="params">(GraphMatrix * graphMatrix,<span class="type">int</span> source)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,vex,min;</span><br><span class="line">    <span class="comment">//found数组用于记录哪些点是新点集合的，哪些不是</span></span><br><span class="line">    <span class="type">int</span>* found = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*graphMatrix-&gt;size);</span><br><span class="line">    <span class="comment">//距离数组，在算法过程中不断更新，最后结果也在这</span></span><br><span class="line">    <span class="type">int</span>* distance = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*graphMatrix-&gt;size);</span><br><span class="line">    <span class="type">int</span>* path = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*graphMatrix-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        found[i] = <span class="number">0</span>;</span><br><span class="line">        path[i] = <span class="number">0</span>;</span><br><span class="line">        distance[i] = graphMatrix-&gt;graph[source][i];</span><br><span class="line">    &#125;<span class="comment">//end 9</span></span><br><span class="line">    <span class="comment">//将起点加入新点集合中</span></span><br><span class="line">    found[source] = <span class="number">1</span>;</span><br><span class="line">    distance[source] = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//每次加入一个点到新点集合中，规则是当前距离最小的</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphMatrix-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        min = MAX;	<span class="comment">//寻找距离最小的点</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!found[j] &amp;&amp; (distance[j]&lt;min))</span><br><span class="line">            &#123;</span><br><span class="line">                vex = j;</span><br><span class="line">                min - distance[j];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end 22</span></span><br><span class="line">        found[vex] = <span class="number">1</span>;	<span class="comment">//找到的点加入新点集合</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>;j&lt;graphMatrix-&gt;size;j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!found[j] &amp;&amp; graphMatrix-&gt;graph[vex][j]!=MAX)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(min+graphMatrix-&gt;graph[vex][j]&lt;distance[j])</span><br><span class="line">                &#123;</span><br><span class="line">                    distance[j] = min + graphMatrix-&gt;graph[vex][j];</span><br><span class="line">                    path[j] = vex;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="comment">//end 31</span></span><br><span class="line">    &#125;<span class="comment">//end 19</span></span><br><span class="line">    <span class="keyword">return</span> distance;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h2 id="拓扑排序（AOV网）"><a href="#拓扑排序（AOV网）" class="headerlink" title="拓扑排序（AOV网）"></a>拓扑排序（AOV网）</h2><ul>
<li>有向图</li>
<li>无环图</li>
<li>定点表示活动</li>
<li>边表示活动间的先后关系</li>
<li>排序方法<ul>
<li>从AOV网中选择一个<code>入度为0</code>的顶点输出</li>
<li>在AOV网中<code>删除</code>此顶点和它的所有出边</li>
<li>反复到输出所有顶点</li>
</ul>
</li>
</ul>
<blockquote>
<p>AOV网的拓扑序列不唯一</p>
<p>有回环不存在拓扑序列</p>
</blockquote>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201217211908.png"></p>
<ul>
<li>算法思路：<ul>
<li>计算各个顶点的入度</li>
<li>将入度为0的顶点入栈</li>
<li>如果栈不空，取出元素 v 并输出</li>
<li>检查顶点 v 的出边表，将出边表中的每个顶点 w 的入度减一，如 w 的入度为 0 ，顶点 w 入栈</li>
<li>重复直到栈空</li>
</ul>
</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">topologicalsort</span><span class="params">(GraphList *graphList)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> nodeNum;</span><br><span class="line">    <span class="type">int</span> success = <span class="number">1</span>;</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="type">int</span>&gt;nodeStack;</span><br><span class="line">    <span class="comment">//使用STL中的stack</span></span><br><span class="line">    GraphListNode *tempNode = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="type">int</span> *inPoint = (<span class="type">int</span>*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(<span class="type">int</span>)*graphList-&gt;size);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)</span><br><span class="line">        inPoint[i] = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)	<span class="comment">//计算顶点的入度</span></span><br><span class="line">    &#123;</span><br><span class="line">        tempNode = graphList-&gt;graphListArray[i].next;</span><br><span class="line">        <span class="keyword">while</span>(tempNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inPoint[tempNode-&gt;nodeno]++;</span><br><span class="line">            tempNode = tempNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;graphList-&gt;size;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(inPoint[i] == <span class="number">0</span>)</span><br><span class="line">            nodeStack.push(i)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span>(!nodeStack.empty())</span><br><span class="line">    &#123;</span><br><span class="line">        nodeNum = nodeStack.top();</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,nodeNum);</span><br><span class="line">        nodeStack.pop();</span><br><span class="line">        count++;</span><br><span class="line">        <span class="comment">//检查v的出边，将每条出边的终端顶点的入度 -1 ，若该顶点的入度为 0 ，入栈</span></span><br><span class="line">        tempNode = graphList-&gt;graphListArray[nodeNum].next;</span><br><span class="line">        <span class="keyword">while</span>(tempNode!=<span class="literal">NULL</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            inPoint[tempNode-&gt;nodeno]--;</span><br><span class="line">            <span class="keyword">if</span>(inPoint[tempNode-&gt;nodeno]==<span class="number">0</span>)</span><br><span class="line">                nodeStack.push(tempNode-&gt;nodeno);</span><br><span class="line">            tempNode = tempNode-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(count!=graphList-&gt;size)</span><br><span class="line">        success = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> success;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="关键路径（AOE网）"><a href="#关键路径（AOE网）" class="headerlink" title="关键路径（AOE网）"></a>关键路径（AOE网）</h2><ul>
<li>带权的有向图</li>
<li>顶点表示时间，有向边表示活动</li>
<li>边上的权值表示活动持续的时间</li>
<li>顶点所表示的事件实际上就是它的入边所表示的活动都已完成，它的出边所表示的活动可以开始这样一种状态</li>
<li>只有一个入度为 0 的顶点</li>
<li>只有一个出度为 0 的顶点</li>
</ul>
<blockquote>
<p>具体算法以后再补</p>
</blockquote>
<h2 id="六度空间"><a href="#六度空间" class="headerlink" title="六度空间"></a>六度空间</h2><blockquote>
<p>有空再学，现在不感兴趣——12.18</p>
</blockquote>
<h2 id="中国邮递员问题"><a href="#中国邮递员问题" class="headerlink" title="中国邮递员问题"></a>中国邮递员问题</h2><blockquote>
<p>有空再学，现在不感兴趣——12.18</p>
</blockquote>
<h1 id="第七章-字典"><a href="#第七章-字典" class="headerlink" title="第七章 字典"></a>第七章 字典</h1><p>字典最重要的就是检索</p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218024417.png"></p>
<h2 id="跳跃链表"><a href="#跳跃链表" class="headerlink" title="跳跃链表"></a>跳跃链表</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>跳跃链表就是在结点中增加指针域，让其直接指向其他的后继结点的指针，使得访问链表的过程中可以交替跳过其直接后继结点</p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218024815.png"></p>
<h3 id="建立和查找"><a href="#建立和查找" class="headerlink" title="建立和查找"></a>建立和查找</h3><ul>
<li>类型定义</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> MAX_LEVEL 6	<span class="comment">//定义最大层数</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType</span><br><span class="line"><span class="comment">//跳跃链表结点结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> level;	<span class="comment">//结点层数</span></span><br><span class="line">    KeyType key;	<span class="comment">//结点的值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">node</span> *<span class="title">next</span>[<span class="title">MAX_LEVEL</span>];</span>	<span class="comment">//指针数组</span></span><br><span class="line">&#125;*PNode;</span><br><span class="line"><span class="comment">//跳跃链表结构定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> num;	<span class="comment">//跳跃链表数据个数</span></span><br><span class="line">    <span class="type">int</span> maxLevel;	<span class="comment">//跳跃链表最大层数</span></span><br><span class="line">    PNode head;	<span class="comment">//跳跃链表的头指针</span></span><br><span class="line">&#125;*SkipList;</span><br></pre></td></tr></table></figure>

<ul>
<li>建立</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">SkipList <span class="title function_">SetNullSkipList</span><span class="params">(<span class="type">int</span> level)</span></span><br><span class="line">&#123;</span><br><span class="line">    SkipList <span class="built_in">list</span> = (SkipList)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SkipList));</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span> == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">list</span>-&gt;num = <span class="number">0</span>;	<span class="comment">//跳跃链表计数器置零</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;maxLevel = level;	<span class="comment">//跳跃链表层数</span></span><br><span class="line">    <span class="built_in">list</span>-&gt;head = CreateNode(level,<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">list</span>-&gt;head == <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">free</span>(<span class="built_in">list</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>;i&lt;level;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">list</span>-&gt;head-&gt;next[i] = <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">list</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">PNode <span class="title function_">CreateNode</span><span class="params">(<span class="type">int</span> level,KeyType key)</span>		<span class="comment">//生成一个新结点</span></span><br><span class="line">&#123;</span><br><span class="line">    PNode p = (PNode)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(PNode) + <span class="keyword">sizeof</span>(PNode)*level);</span><br><span class="line">    <span class="keyword">if</span>(p == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    p-&gt;level = level;</span><br><span class="line">    p-&gt;key = key;</span><br><span class="line">    <span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>查找</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">PNode <span class="title function_">SkipListSearch</span><span class="params">(SkipList <span class="built_in">list</span>,KeyType key)</span>	<span class="comment">//按值查找</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> n = <span class="number">0</span>;</span><br><span class="line">    PNode p = <span class="literal">NULL</span>;</span><br><span class="line">    q = <span class="literal">NULL</span>;</span><br><span class="line">    p = <span class="built_in">list</span>-&gt;head;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i =<span class="built_in">list</span>-&gt;maxLevel <span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((q = p-&gt;next[i]) &amp;&amp; (q-&gt;key &lt;= key))	<span class="comment">//横向比较</span></span><br><span class="line">        &#123;</span><br><span class="line">            p = q;</span><br><span class="line">            n++;</span><br><span class="line">            <span class="keyword">if</span>(p-&gt;key == key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,n);</span><br><span class="line">                <span class="keyword">return</span> p;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



<h3 id="插入和删除"><a href="#插入和删除" class="headerlink" title="插入和删除"></a>插入和删除</h3><blockquote>
<p>有空补</p>
</blockquote>
<h2 id="散列表"><a href="#散列表" class="headerlink" title="散列表"></a>散列表</h2><h3 id="散列函数和冲突"><a href="#散列函数和冲突" class="headerlink" title="散列函数和冲突"></a>散列函数和冲突</h3><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218045225.png"></p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218045305.png"></p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218050453.png"></p>
<p> <img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218051049.png"></p>
<h3 id="散列表的建立、查找、插入和删除"><a href="#散列表的建立、查找、插入和删除" class="headerlink" title="散列表的建立、查找、插入和删除"></a>散列表的建立、查找、插入和删除</h3><ul>
<li>查找</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218051339.png"></p>
<ul>
<li>插入</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218052735.png"></p>
<ul>
<li>删除</li>
</ul>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218052836.png"></p>
<h1 id="第九章-排序"><a href="#第九章-排序" class="headerlink" title="第九章 排序"></a>第九章 排序</h1><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218053313.png"></p>
<ul>
<li>待排序的记录，采用顺序存储结构</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> KeyType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> InfoType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">RECORDTYPE_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    KeyType key;	<span class="comment">//关键字</span></span><br><span class="line">    InfoType otherInfo;	<span class="comment">//其他数据信息</span></span><br><span class="line">&#125;RecordType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">SORTARRAY_STRU</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> cnt;	<span class="comment">//记录排序数组中元素个数</span></span><br><span class="line">    RecordType *recordArr;	<span class="comment">//指向一维数组的指针</span></span><br><span class="line">&#125;SortArr;</span><br></pre></td></tr></table></figure>

<ul>
<li>交换函数</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">Swap</span><span class="params">(SortArr* sortArr,<span class="type">int</span> i,<span class="type">int</span> j)</span></span><br><span class="line">&#123;</span><br><span class="line">    KeyType temp;</span><br><span class="line">    temp = sortArr-&gt;recordArr[i].key;</span><br><span class="line">    sortArr-&gt;recordArr[i].key = sortArr-&gt;recordArr[j].key;</span><br><span class="line">    sortArr-&gt;recordArr[j].key = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="插入类排序"><a href="#插入类排序" class="headerlink" title="插入类排序"></a>插入类排序</h2><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218054123.png"></p>
<h3 id="直接插入排序"><a href="#直接插入排序" class="headerlink" title="直接插入排序"></a>直接插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">InsertSort</span><span class="params">(SortArr* sortArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecordType temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;sortArr-&gt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        j = i - <span class="number">1</span>;	<span class="comment">//j是已经排好顺序的数据最后一个元素的下标</span></span><br><span class="line">        temp = sortArr-&gt;recordArr[i];	<span class="comment">//等待插入的数据temp</span></span><br><span class="line">        <span class="comment">//从j位置开始，从后向前在已经排好顺序的序列中找到插入位置</span></span><br><span class="line">        <span class="keyword">while</span>(temp.key&lt;sortArr-&gt;recordArr[j].key &amp;&amp; j&gt;=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            sortArr-&gt;recordArr[j+<span class="number">1</span>] = sortArr-&gt;recordArr[j];	<span class="comment">//待插入元素比有序序列中元素小，有序序列中元素往前移</span></span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//找到待插入位置为 j+1</span></span><br><span class="line">        <span class="comment">//如果待插入位置正好就是要插入元素所在位置则可以不进行数据赋值</span></span><br><span class="line">        <span class="keyword">if</span>((j+<span class="number">1</span>) != i)</span><br><span class="line">            sortArr-&gt;recordArr[j+<span class="number">1</span>] = temp;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法是<code>稳定</code>的</li>
<li>适用于<code>n较小</code>的序列</li>
</ul>
<h3 id="二分插入排序"><a href="#二分插入排序" class="headerlink" title="二分插入排序"></a>二分插入排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">BinSort</span><span class="params">(SortArr* sortArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> low,mid,high;</span><br><span class="line">    RecordType temp;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;sortArr-&gt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        temp = sortArr-&gt;recordArr[i];</span><br><span class="line">        low = <span class="number">0</span>;</span><br><span class="line">        high = i - <span class="number">1</span>;	<span class="comment">//区分左右边界</span></span><br><span class="line">        <span class="keyword">while</span>(low &lt;=high)</span><br><span class="line">        &#123;</span><br><span class="line">            mid = (low + high)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(temp.key &lt;sortArr-&gt;recordArr[mid].key)</span><br><span class="line">                high = mid - <span class="number">1</span>;	<span class="comment">//待排序的值比中间位置的值小，在前半区查找</span></span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//如果待插入数据正好在还要插入的位置上就不用插入</span></span><br><span class="line">        <span class="keyword">if</span>(low != i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//如果需要挪动数据，空出位置，插入数据</span></span><br><span class="line">            <span class="comment">//找到插入位置后，移动数据，空出位置</span></span><br><span class="line">            <span class="keyword">for</span>(j = i - <span class="number">1</span>;j&gt;=low;j--)</span><br><span class="line">                sortArr-&gt;recordArr[j+<span class="number">1</span>] = sortArr-&gt;recordArr[j];</span><br><span class="line">            sortArr-&gt;recordArr[low] = temp;	<span class="comment">//插入数据</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法是<code>稳定</code>的</li>
<li><code>链表无法折半</code></li>
</ul>
<h3 id="表插入排序"><a href="#表插入排序" class="headerlink" title="表插入排序"></a>表插入排序</h3><blockquote>
<p>以后有空补</p>
</blockquote>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">ShellSort</span><span class="params">(SortArr* sortArr,<span class="type">int</span> d)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j,increment;	<span class="comment">//increment记录当前躺的增量</span></span><br><span class="line">    RecordType temp;	<span class="comment">//保存待排序记录</span></span><br><span class="line">    <span class="keyword">for</span>(increment = d;increment&gt;<span class="number">0</span>;increment /= <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(i = increment;i&lt;sortArr-&gt;count;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            temp = sortArr-&gt;recordArr[i];	<span class="comment">//保存待排序记录</span></span><br><span class="line">            j = i - increment;	<span class="comment">//j按照增量进行变化</span></span><br><span class="line">            <span class="keyword">while</span>(j&gt;=<span class="number">0</span> &amp;&amp; temp.key&lt;sortArr-&gt;recordArr[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="comment">//记录按照增量间隔向后移动</span></span><br><span class="line">                sortArr-&gt;recordArr[j+increment] = sortArr-&gt;recordArr[j];</span><br><span class="line">                j -= increment;	<span class="comment">//j按照增量进行变化</span></span><br><span class="line">            &#125;</span><br><span class="line">            sortArr-&gt;recordArr[j+increment] = temp;	<span class="comment">//插入待排序记录</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法是不稳定的</li>
</ul>
<h2 id="选择类排序"><a href="#选择类排序" class="headerlink" title="选择类排序"></a>选择类排序</h2><h3 id="直接选择排序"><a href="#直接选择排序" class="headerlink" title="直接选择排序"></a>直接选择排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">SelectSort</span><span class="params">(SortArr* sortArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> minPos;	<span class="comment">//记录最小元素的下标</span></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;sortArr-&gt;count<span class="number">-1</span>;i++)	<span class="comment">//n-1躺的选择排序</span></span><br><span class="line">    &#123;</span><br><span class="line">        minPos = i;		<span class="comment">//记录最小的值所在的数组下标</span></span><br><span class="line">        <span class="keyword">for</span>(j = i+<span class="number">1</span>;j&lt;sortArr-&gt;count;j++)	<span class="comment">//在无序区域中寻找</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(sortArr-&gt;recordArr[j].key &lt; sortArr-&gt;recordArr[minPos].key)</span><br><span class="line">                minPos = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(minPos != i)	<span class="comment">//说明需要交换</span></span><br><span class="line">            Swap(sortArr,minPos,i);	<span class="comment">//调用交换函数</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法是<code>不稳定</code>的</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><ul>
<li>根结点大于其左右孩子——<code>大根堆</code></li>
<li>根结点小于其左右孩子——<code>小根堆</code></li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>后面再补</p>
</blockquote>
<h2 id="交换类排序"><a href="#交换类排序" class="headerlink" title="交换类排序"></a>交换类排序</h2><h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//此算法为冒小泡，每次把最小的移动到最左边</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">BubbleSort</span><span class="params">(SortArr *sortArr)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    <span class="type">int</span> hasSwap = <span class="number">0</span>;	<span class="comment">//标志，用于检测内循环是否还有数据交换</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">1</span>;i&lt;sortArr-&gt;count;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        hasSwap = <span class="number">0</span>;	<span class="comment">//每趟开始重新设置交换标志为 0 </span></span><br><span class="line">        <span class="comment">//j是从后往前循环，数组的下标是 0 到 count - 1</span></span><br><span class="line">        <span class="keyword">for</span>(j = sortArr-&gt;count - <span class="number">1</span>;j&gt;=i;j--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//若前者大于后者</span></span><br><span class="line">            <span class="keyword">if</span>(sortArr-&gt;recordArr[j<span class="number">-1</span>].key&gt;sortArr-&gt;recordArr[j].key)</span><br><span class="line">            &#123;</span><br><span class="line">                Swap(sortArr,j,j<span class="number">-1</span>);</span><br><span class="line">                hsaSwap = <span class="number">1</span>;	<span class="comment">//有交换则设置为 1</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!hasSwap)	<span class="comment">//本躺没有发生交换</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法是<code>稳定</code>的</li>
</ul>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218184027.png"></p>
<p><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/20201218185500.png"></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">void</span> <span class="title function_">quickSort</span><span class="params">(SortObject *pvector,<span class="type">int</span> l,<span class="type">int</span> r)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i,j;</span><br><span class="line">    RecordNode temp;</span><br><span class="line">    <span class="keyword">if</span>(l&gt;=r)	<span class="comment">//只有一个记录或无记录，不用排序</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    i = l;</span><br><span class="line">    j = r;</span><br><span class="line">    temp = pvector-&gt;record[i];	<span class="comment">//把枢轴放到temp里面</span></span><br><span class="line">    <span class="keyword">while</span>(i!=j)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">while</span>((pvector-&gt;record[j].key &gt;= temp.key) &amp;&amp; (j&gt;i))</span><br><span class="line">            j--;	<span class="comment">//从右向左扫描，直到查找到第一个小于temp.key的记录</span></span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            pvector-&gt;record[i++] = pvector-&gt;record[j];</span><br><span class="line">        <span class="keyword">while</span>((pvector-&gt;record[i].key &lt;= temp.key) &amp;&amp; (j&gt;i))</span><br><span class="line">            i++;</span><br><span class="line">        <span class="keyword">if</span>(i&lt;j)</span><br><span class="line">            pvector-&gt;record[j--] = pvector-&gt;record[i];</span><br><span class="line">    &#125;</span><br><span class="line">    pvector-&gt;record[i] = temp;</span><br><span class="line">    quickSort(pvector,l,i<span class="number">-1</span>);</span><br><span class="line">    quickSort(pvector,i+<span class="number">1</span>,r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>算法是<code>不稳定</code>的</li>
</ul>
<h2 id="分配类排序"><a href="#分配类排序" class="headerlink" title="分配类排序"></a>分配类排序</h2><h3 id="基数排序"><a href="#基数排序" class="headerlink" title="基数排序"></a>基数排序</h3><blockquote>
<p>以后有空补</p>
</blockquote>
<h2 id="归并类排序"><a href="#归并类排序" class="headerlink" title="归并类排序"></a>归并类排序</h2><h3 id="两路归并"><a href="#两路归并" class="headerlink" title="两路归并"></a>两路归并</h3><blockquote>
<p>以后有空补</p>
</blockquote>
<h3 id="多路归并"><a href="#多路归并" class="headerlink" title="多路归并"></a>多路归并</h3><blockquote>
<p>以后有空补</p>
</blockquote>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者: </span><span class="post-copyright-info"><a href="http://C1everF0x.top">C1everF0x</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接: </span><span class="post-copyright-info"><a href="http://c1everf0x.top/posts/24342/">http://c1everf0x.top/posts/24342/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="http://C1everF0x.top" target="_blank">C1everF0x的博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">数据结构</a></div><div class="post_share"><div class="social-share" data-image="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/10.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/61314/"><img class="prev-cover" src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/15.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">SQL注入总结</div></div></a></div><div class="next-post pull-right"><a href="/posts/25736/"><img class="next-cover" src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/11.jpg" onerror="onerror=null;src='/img/404.jpg'" alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">pikachu靶场通关</div></div></a></div></nav></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="http://q1.qlogo.cn/g?b=qq&amp;nk=1160118161&amp;s=640" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">C1everF0x</div><div class="author-info__description">压力面前保持优雅</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">34</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">18</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">7</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/C1everF0x"><i class="fab fa-github"></i><span>Follow Me</span></a><div class="card-info-social-icons is-center"><a class="social-icon" href="https://github.com/C1everF0x" target="_blank" title="Github"><i class="fab fa-github"></i></a><a class="social-icon" href="mailto:Oui0jr@163.com" target="_blank" title="Email"><i class="fas fa-envelope"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">你好，不好也可以，随便你</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E7%AB%A0-%E7%BB%AA%E8%AE%BA"><span class="toc-text">第一章 绪论</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8A%BD%E8%B1%A1%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%EF%BC%88Abstract-Data-Type%EF%BC%8CADT%EF%BC%89"><span class="toc-text">抽象数据类型（Abstract Data Type，ADT）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E7%BC%96%E7%A8%8B%E6%8E%A5%E5%8F%A3%EF%BC%88Application-Program-Interface%EF%BC%8CAPI%EF%BC%89"><span class="toc-text">应用程序编程接口（Application Program Interface，API）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84"><span class="toc-text">数据结构</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%8C%E8%AF%9D"><span class="toc-text">行话</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E9%80%BB%E8%BE%91%E7%BB%93%E6%9E%84"><span class="toc-text">数据的逻辑结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E5%AD%98%E5%82%A8%E7%BB%93%E6%9E%84"><span class="toc-text">数据的存储结构</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%B0%E6%8D%AE%E7%9A%84%E6%93%8D%E4%BD%9C"><span class="toc-text">数据的操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AE%97%E6%B3%95%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">算法复杂度</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%B6%E9%97%B4%E5%A4%8D%E6%9D%82%E5%BA%A6"><span class="toc-text">时间复杂度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95"><span class="toc-text">分析方法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%BE%E4%BE%8B"><span class="toc-text">举例</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%8C%E7%AB%A0-%E7%BA%BF%E6%80%A7%E8%A1%A8"><span class="toc-text">第二章 线性表</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8"><span class="toc-text">顺序表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">顺序表类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%88%A4%E7%A9%BA"><span class="toc-text">顺序表建立和判空</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%8F%92%E5%85%A5%E5%85%83%E7%B4%A0"><span class="toc-text">顺序表插入元素</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-text">顺序表删除</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E8%A1%A8%E6%9F%A5%E6%89%BE%E5%AE%9A%E4%BD%8D"><span class="toc-text">顺序表查找定位</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">单链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E8%A1%A8%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">链表类型定义</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BB%BA%E7%AB%8B%E5%92%8C%E5%88%A4%E7%A9%BA"><span class="toc-text">单链表建立和判空</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%A4%B4%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E9%9D%9E%E7%A9%BA%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">头插法建立非空单链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%B0%BE%E6%8F%92%E6%B3%95%E5%BB%BA%E7%AB%8B%E5%8D%95%E9%93%BE%E8%A1%A8"><span class="toc-text">尾插法建立单链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%9F%A5%E6%89%BE"><span class="toc-text">单链表查找</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E6%9F%A5%E6%89%BE"><span class="toc-text">按值查找</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E7%85%A7%E5%BA%8F%E5%8F%B7%E6%9F%A5%E6%89%BE"><span class="toc-text">按照序号查找</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5"><span class="toc-text">单链表插入</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E6%8F%92%E6%B3%95"><span class="toc-text">后插法</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%89%8D%E6%8F%92%E6%B3%95"><span class="toc-text">前插法</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-text">单链表删除</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E7%9A%84%E5%90%8E%E7%BB%A7"><span class="toc-text">删除结点的后继</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A0%E9%99%A4%E7%BB%93%E7%82%B9%E6%9C%AC%E8%BA%AB"><span class="toc-text">删除结点本身</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E6%8C%89%E5%80%BC%E5%88%A0%E9%99%A4"><span class="toc-text">按值删除</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E9%93%BE%E8%A1%A8%E9%80%86%E7%BD%AE"><span class="toc-text">单链表逆置</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">单循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%A4%E4%B8%AA%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8%E5%90%88%E5%B9%B6%E6%88%90%E4%B8%80%E4%B8%AA%E6%96%B0%E7%9A%84%E5%8D%95%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">两个单循环链表合并成一个新的单循环链表</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%92%8C%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">双链表和双循环链表</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8"><span class="toc-text">双链表</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E5%88%A0%E9%99%A4"><span class="toc-text">双链表删除</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E9%93%BE%E8%A1%A8%E6%8F%92%E5%85%A5"><span class="toc-text">双链表插入</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%8C%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8"><span class="toc-text">双循环链表</span></a></li></ol></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%89%E7%AB%A0-%E6%A0%88%E5%92%8C%E9%98%9F%E5%88%97"><span class="toc-text">第三章 栈和队列</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%88"><span class="toc-text">栈</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E6%B7%B7%E6%B4%97"><span class="toc-text">栈混洗</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88"><span class="toc-text">顺序栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">顺序栈类型定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%A9%BA%E6%A0%88"><span class="toc-text">创建空栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%A1%BA%E5%BA%8F%E6%A0%88%E5%88%A4%E7%A9%BA"><span class="toc-text">顺序栈判空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88"><span class="toc-text">进栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88"><span class="toc-text">出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0"><span class="toc-text">取栈顶元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E6%A0%88"><span class="toc-text">链栈</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E6%A0%88%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">链栈类型定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%A9%BA%E6%A0%88-1"><span class="toc-text">创建空栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E6%A0%88%E7%A9%BA"><span class="toc-text">判断栈空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BF%9B%E6%A0%88-1"><span class="toc-text">进栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E6%A0%88-1"><span class="toc-text">出栈</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E6%A0%88%E9%A1%B6%E5%85%83%E7%B4%A0-1"><span class="toc-text">取栈顶元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%EF%BC%9A%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2"><span class="toc-text">栈实现：进制转换</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%85%AB%E8%BF%9B%E5%88%B6"><span class="toc-text">转八进制</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E8%BD%AC%E5%8D%81%E5%85%AD%E8%BF%9B%E5%88%B6"><span class="toc-text">转十六进制</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%88%E5%AE%9E%E7%8E%B0%EF%BC%9A%E6%8B%AC%E5%8F%B7%E5%8C%B9%E9%85%8D"><span class="toc-text">栈实现：括号匹配</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%98%9F%E5%88%97"><span class="toc-text">队列</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97"><span class="toc-text">循环队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E9%98%9F%E5%88%97%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">循环队列类型定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%98%9F%E5%88%97"><span class="toc-text">创建空队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA"><span class="toc-text">判断队空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%98%9F"><span class="toc-text">入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E9%98%9F"><span class="toc-text">出队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0"><span class="toc-text">取队头元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97"><span class="toc-text">链队列</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E9%93%BE%E9%98%9F%E5%88%97%E7%B1%BB%E5%9E%8B%E5%AE%9A%E4%B9%89"><span class="toc-text">链队列类型定义</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%9B%E5%BB%BA%E7%A9%BA%E9%98%9F%E5%88%97-1"><span class="toc-text">创建空队列</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%88%A4%E6%96%AD%E9%98%9F%E7%A9%BA-1"><span class="toc-text">判断队空</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%A5%E9%98%9F-1"><span class="toc-text">入队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%87%BA%E9%98%9F-1"><span class="toc-text">出队</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%8F%96%E9%98%9F%E5%A4%B4%E5%85%83%E7%B4%A0-1"><span class="toc-text">取队头元素</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8F%8C%E7%AB%AF%E9%98%9F%E5%88%97"><span class="toc-text">双端队列</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">第四章 树与二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">二叉树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E5%9F%BA%E6%9C%AC%E6%9C%AF%E8%AF%AD"><span class="toc-text">二叉树基本术语</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E7%9A%84%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">特殊的二叉树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">满二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">完全二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%89%A9%E5%85%85%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">扩充二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%80%A7%E8%B4%A8"><span class="toc-text">二叉树的性质</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的深度遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86"><span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%B9%BF%E5%BA%A6%E9%81%8D%E5%8E%86%EF%BC%88%E5%B1%82%E6%AC%A1%E9%81%8D%E5%8E%86%EF%BC%89"><span class="toc-text">二叉树的广度遍历（层次遍历）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%BA%A4%E5%8F%89%E9%81%8D%E5%8E%86"><span class="toc-text">二叉树的交叉遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%87%8D%E6%9E%84"><span class="toc-text">二叉树的重构</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%AD%98%E5%82%A8"><span class="toc-text">二叉树的存储</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%A1%BA%E5%BA%8F%E5%AD%98%E5%82%A8%EF%BC%88%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-text">二叉树的顺序存储（完全二叉树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%93%BE%E5%BC%8F%E5%AD%98%E5%82%A8%EF%BC%88%E4%B8%80%E8%88%AC%E4%BA%8C%E5%8F%89%E6%A0%91%EF%BC%89"><span class="toc-text">二叉树的链式存储（一般二叉树）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BA%BF%E7%B4%A2%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">线索二叉树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E9%80%92%E5%BD%92%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%B8%8E%E9%81%8D%E5%8E%86"><span class="toc-text">（递归）二叉树的建立与遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-1"><span class="toc-text">后序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%EF%BC%88%E5%B1%82%E6%AC%A1%EF%BC%89%E9%81%8D%E5%8E%86"><span class="toc-text">广度（层次）遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%EF%BC%88%E9%9D%9E%E9%80%92%E5%BD%92%EF%BC%89%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%BB%BA%E7%AB%8B%E4%BA%8E%E9%81%8D%E5%8E%86"><span class="toc-text">（非递归）二叉树的建立于遍历</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%88%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-text">先序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%AD%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-text">中序遍历</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%8E%E5%BA%8F%E9%81%8D%E5%8E%86-2"><span class="toc-text">后序遍历</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E5%85%B6%E4%BB%96%E6%93%8D%E4%BD%9C"><span class="toc-text">二叉树的其他操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B6%E5%AD%90%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">统计二叉树叶子结点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E6%80%BB%E7%9A%84%E7%BB%93%E7%82%B9%E4%B8%AA%E6%95%B0"><span class="toc-text">统计二叉树总的结点个数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%9F%E8%AE%A1%E4%BA%8C%E5%8F%89%E6%A0%91%E5%8F%B3%E7%BB%93%E7%82%B9%E6%95%B0"><span class="toc-text">统计二叉树右结点数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%AE%A1%E7%AE%97%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%B7%B1%E5%BA%A6"><span class="toc-text">计算二叉树的深度</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9F%A5%E6%89%BE%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0"><span class="toc-text">查找数据元素</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%A0%91%E5%92%8C%E6%A3%AE%E6%9E%97"><span class="toc-text">树和森林</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A0%91%E3%80%81%E6%A3%AE%E6%9E%97%E8%BD%AC%E4%B8%BA%E4%BA%8C%E5%8F%89%E6%A0%91"><span class="toc-text">树、森林转为二叉树</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%8F%89%E6%A0%91%E8%BD%AC%E6%8D%A2%E4%B8%BA%E6%A0%91%E6%88%96%E6%A3%AE%E6%9E%97"><span class="toc-text">二叉树转换为树或森林</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E6%A0%91"><span class="toc-text">哈夫曼树</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%AE%97%E6%B3%95"><span class="toc-text">哈夫曼算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%93%88%E5%A4%AB%E6%9B%BC%E7%BC%96%E7%A0%81%EF%BC%88%E6%9C%80%E4%BC%98%E5%89%8D%E7%BC%80%E7%BC%96%E7%A0%81%EF%BC%89"><span class="toc-text">哈夫曼编码（最优前缀编码）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E5%9B%9B%E7%AB%A0-%E6%90%9C%E7%B4%A2%E6%A0%91"><span class="toc-text">第四章 搜索树</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E5%88%A4%E5%AE%9A%E6%9F%A5%E6%89%BE%E6%A0%91"><span class="toc-text">二分判定查找树</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88BST%EF%BC%89%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">二分排序树（BST）的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%9F%A5%E6%89%BE"><span class="toc-text">二分排序树的查找</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E6%8F%92%E5%85%A5"><span class="toc-text">二分排序树的插入</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%8E%92%E5%BA%8F%E6%A0%91%E7%9A%84%E5%88%A0%E9%99%A4"><span class="toc-text">二分排序树的删除</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%8E%92%E5%BA%8F%E6%A0%91%EF%BC%88AVL%EF%BC%89%E7%9A%84%E6%A6%82%E5%BF%B5"><span class="toc-text">平衡二叉排序树（AVL）的概念</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#AVL%E6%A0%91"><span class="toc-text">AVL树</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#AVL%E6%A0%91%E7%9A%84%E5%9B%9B%E7%A7%8D%E8%B0%83%E6%95%B4"><span class="toc-text">AVL树的四种调整</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%BA%94%E7%AB%A0-%E5%9B%BE"><span class="toc-text">第五章 图</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">图的基本概念</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%AD%98%E5%82%A8%E8%A1%A8%E7%A4%BA"><span class="toc-text">图的存储表示</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E7%9F%A9%E9%98%B5%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">邻接矩阵表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">邻接表表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%82%BB%E6%8E%A5%E5%A4%9A%E9%87%8D%E8%A1%A8%E8%A1%A8%E7%A4%BA%E6%B3%95"><span class="toc-text">邻接多重表表示法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%8D%81%E5%AD%97%E9%93%BE%E8%A1%A8"><span class="toc-text">图的十字链表</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%BE%E7%9A%84%E5%91%A8%E6%B8%B8"><span class="toc-text">图的周游</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88DFS%EF%BC%89"><span class="toc-text">深度优先搜索（DFS）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2%EF%BC%88BFS%EF%BC%89"><span class="toc-text">广度优先搜索（BFS）</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%EF%BC%88MST%EF%BC%89"><span class="toc-text">最小生成树（MST）</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Prim%E7%AE%97%E6%B3%95"><span class="toc-text">Prim算法</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Kruskai%E7%AE%97%E6%B3%95"><span class="toc-text">Kruskai算法</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Dijstra%E7%AE%97%E6%B3%95"><span class="toc-text">Dijstra算法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F%EF%BC%88AOV%E7%BD%91%EF%BC%89"><span class="toc-text">拓扑排序（AOV网）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%B3%E9%94%AE%E8%B7%AF%E5%BE%84%EF%BC%88AOE%E7%BD%91%EF%BC%89"><span class="toc-text">关键路径（AOE网）</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%85%AD%E5%BA%A6%E7%A9%BA%E9%97%B4"><span class="toc-text">六度空间</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%AD%E5%9B%BD%E9%82%AE%E9%80%92%E5%91%98%E9%97%AE%E9%A2%98"><span class="toc-text">中国邮递员问题</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B8%83%E7%AB%A0-%E5%AD%97%E5%85%B8"><span class="toc-text">第七章 字典</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%B7%B3%E8%B7%83%E9%93%BE%E8%A1%A8"><span class="toc-text">跳跃链表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5"><span class="toc-text">基本概念</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BB%BA%E7%AB%8B%E5%92%8C%E6%9F%A5%E6%89%BE"><span class="toc-text">建立和查找</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">插入和删除</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8"><span class="toc-text">散列表</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E5%87%BD%E6%95%B0%E5%92%8C%E5%86%B2%E7%AA%81"><span class="toc-text">散列函数和冲突</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%95%A3%E5%88%97%E8%A1%A8%E7%9A%84%E5%BB%BA%E7%AB%8B%E3%80%81%E6%9F%A5%E6%89%BE%E3%80%81%E6%8F%92%E5%85%A5%E5%92%8C%E5%88%A0%E9%99%A4"><span class="toc-text">散列表的建立、查找、插入和删除</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E7%AC%AC%E4%B9%9D%E7%AB%A0-%E6%8E%92%E5%BA%8F"><span class="toc-text">第九章 排序</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8F%92%E5%85%A5%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="toc-text">插入类排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">直接插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">二分插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%A1%A8%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F"><span class="toc-text">表插入排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F"><span class="toc-text">希尔排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%80%89%E6%8B%A9%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="toc-text">选择类排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%9B%B4%E6%8E%A5%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F"><span class="toc-text">直接选择排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A0%86%E6%8E%92%E5%BA%8F"><span class="toc-text">堆排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%A4%E6%8D%A2%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="toc-text">交换类排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F"><span class="toc-text">冒泡排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F"><span class="toc-text">快速排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E9%85%8D%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="toc-text">分配类排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F"><span class="toc-text">基数排序</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BD%92%E5%B9%B6%E7%B1%BB%E6%8E%92%E5%BA%8F"><span class="toc-text">归并类排序</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E4%B8%A4%E8%B7%AF%E5%BD%92%E5%B9%B6"><span class="toc-text">两路归并</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A4%9A%E8%B7%AF%E5%BD%92%E5%B9%B6"><span class="toc-text">多路归并</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/16107/" title="Hello World"><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="Hello World"/></a><div class="content"><a class="title" href="/posts/16107/" title="Hello World">Hello World</a><time datetime="2023-02-13T07:17:14.692Z" title="发表于 2023-02-13 07:17:14">2023-02-13</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/20199/" title="llvm代码混淆学习（三）"><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/12.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="llvm代码混淆学习（三）"/></a><div class="content"><a class="title" href="/posts/20199/" title="llvm代码混淆学习（三）">llvm代码混淆学习（三）</a><time datetime="2023-02-08T00:54:48.000Z" title="发表于 2023-02-08 00:54:48">2023-02-08</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/17054/" title="llvm代码混淆学习（二）"><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/16.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="llvm代码混淆学习（二）"/></a><div class="content"><a class="title" href="/posts/17054/" title="llvm代码混淆学习（二）">llvm代码混淆学习（二）</a><time datetime="2023-02-07T04:53:12.000Z" title="发表于 2023-02-07 04:53:12">2023-02-07</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/34623/" title="《潜水员戴夫》游戏测评"><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/19.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="《潜水员戴夫》游戏测评"/></a><div class="content"><a class="title" href="/posts/34623/" title="《潜水员戴夫》游戏测评">《潜水员戴夫》游戏测评</a><time datetime="2023-02-06T19:55:12.000Z" title="发表于 2023-02-06 19:55:12">2023-02-06</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/53988/" title="llvm代码混淆学习（一）"><img src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/14.jpg" onerror="this.onerror=null;this.src='/img/404.jpg'" alt="llvm代码混淆学习（一）"/></a><div class="content"><a class="title" href="/posts/53988/" title="llvm代码混淆学习（一）">llvm代码混淆学习（一）</a><time datetime="2023-02-03T02:01:41.000Z" title="发表于 2023-02-03 02:01:41">2023-02-03</time></div></div></div></div></div></div></main><footer id="footer" style="background-image: url('https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/10.jpg')"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2023  <i id="heartbeat" class="fa fas fa-heartbeat"></i> C1everF0x</div><div class="footer_custom_text">能注意到这个地方也蛮离谱的</div><div class="framework-info"> <span class="footer-separator"> </span><a target="_blank" rel="noopener" href="https://hexo.io"><img class="entered loading" src="https://alpha-blog-image.oss-cn-shenzhen.aliyuncs.com/image/Frame-Hexo-blue.svg" title="博客框架用的Hexo" alt="博客框架用的Hexo" data-ll-status="loading"/></a><span class="footer-separator"> </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly"><img class="entered loading" src="https://alpha-blog-image.oss-cn-shenzhen.aliyuncs.com/image/Theme-Butterfly-6513df.svg" title="博客主题用的butterfly" alt="博客主题用的butterfly" data-ll-status="loading"/></a><span class="footer-separator"> </span><a target="_blank" rel="noopener" href="https://github.com/"><img class="entered loading" src="https://alpha-blog-image.oss-cn-shenzhen.aliyuncs.com/image/Source-Github-d021d6.svg" title="博客源码由GitHub托管" alt="博客源码由GitHub托管" data-ll-status="loading"/></a><span class="footer-separator"> </span><a target="_blank" rel="noopener" href="https://creativecommons.org/licenses/by-nc-sa/4.0/"><img class="entered loading" src="https://alpha-blog-image.oss-cn-shenzhen.aliyuncs.com/image/Copyright-BY--NC--SA%204.svg" title="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" alt="本站采用知识共享署名-非商业性使用-相同方式共享4.0国际许可协议进行许可" data-ll-status="loading"/></a></div></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/HCLonely/images@master/others/heartbeat.min.css"></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i><span>  数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"/></div></div><hr/><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.min.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="/js/search/local-search.js"></script><div class="js-pjax"></div><script src="/js/title.js"></script><script id="canvas_nest" defer="defer" color="0,0,255" opacity="0.7" zIndex="-1" count="99" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/canvas-nest.min.js"></script><script id="click-heart" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc/dist/click-heart.min.js" async="async" mobile="false"></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><!-- hexo injector body_end start --> <script data-pjax>if(document.getElementById('recent-posts') && (location.pathname ==='/'|| '/' ==='all')){
    var parent = document.getElementById('recent-posts');
    var child = '<div class="recent-post-item" style="width:100%;height: auto"><div id="catalog_magnet"><div class="magnet_item"><a class="magnet_link" href="http://C1everF0x.top/categories/CTF/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📋 CTF做题记录 (2)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://C1everF0x.top/categories/游戏测评/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🧙‍♂️ 玩过的游戏测评与总结 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://C1everF0x.top/categories/生活杂记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🍺 生活杂记 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://C1everF0x.top/categories/hack技术/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">😎 hacked by Aimerl0 (8)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://C1everF0x.top/categories/读后感和观后感/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">💡 读后感和观后感 (1)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://C1everF0x.top/categories/学习笔记/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">📒 课程和论文的学习笔记 (9)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item"><a class="magnet_link" href="http://C1everF0x.top/categories/年终总结/"><div class="magnet_link_context" style=""><span style="font-weight:500;flex:1">🦊 年终总结 (3)</span><span style="padding:0px 4px;border-radius: 8px;"><i class="fas fa-arrow-circle-right"></i></span></div></a></div><div class="magnet_item" style="visibility: hidden"></div><a class="magnet_link_more"  href="http://C1everF0x.top/categories" style="flex:1;text-align: center;margin-bottom: 10px;">查看更多...</a></div></div>';
    console.log('已挂载magnet')
    parent.insertAdjacentHTML("afterbegin",child)}
     </script><style>#catalog_magnet{flex-wrap: wrap;display: flex;width:100%;justify-content:space-between;padding: 10px 10px 0 10px;align-content: flex-start;}.magnet_item{flex-basis: calc(50% - 5px);background: #f2f2f2;margin-bottom: 10px;border-radius: 8px;transition: all 0.2s ease-in-out;}.magnet_item:hover{background: #b30070}.magnet_link_more{color:#555}.magnet_link{color:black}.magnet_link:hover{color:white}@media screen and (max-width: 600px) {.magnet_item {flex-basis: 100%;}}.magnet_link_context{display:flex;padding: 10px;font-size:16px;transition: all 0.2s ease-in-out;}.magnet_link_context:hover{padding: 10px 20px;}</style>
    <style></style><script data-pjax>function electric_clock_injector_config(){
                var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
                var item_html = 'undefined';
                console.log('已挂载electric_clock')
                // parent_div_git.innerHTML=item_html+parent_div_git.innerHTML // 无报错，但不影响使用(支持pjax跳转)
                parent_div_git.insertAdjacentHTML("afterbegin",item_html) // 有报错，但不影响使用(支持pjax跳转)
            }if( document.getElementsByClassName('sticky_layout')[0] && (location.pathname ==='all'|| 'all' ==='all')){

            electric_clock_injector_config()
        } </script><script src="https://pv.sohu.com/cityjson?ie=utf-8"></script><script data-pjax  src="https://cdn.jsdelivr.net/gh/Zfour/hexo-electric-clock@1.0.6/clock.js"></script><script data-pjax>
  function butterfly_clock_anzhiyu_injector_config(){
    var parent_div_git = document.getElementsByClassName('sticky_layout')[0];
    var item_html = '<div class="card-widget card-clock"><div class="card-glass"><div class="card-background"><div class="card-content"><div id="hexo_electric_clock"><img class="entered loading" id="card-clock-loading" src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/loading.gif" style="height: 120px; width: 100%;" data-ll-status="loading"/></div></div></div></div></div>';
    console.log('已挂载butterfly_clock_anzhiyu')
    if(parent_div_git) {
      parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  }
  var elist = 'null'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var qweather_key = '40dd9fe8b86e40109b7630f3405a15fe';
  var gaud_map_key = 'cabe7a87dda36debc35dcc7ccc2704f0';
  var baidu_ak_key = 'undefined';
  var flag = 0;
  var clock_rectangle = '110.420473,25.321738';
  var clock_default_rectangle_enable = 'false';

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_clock_anzhiyu_injector_config();
  }
  else if (epage === cpage){
    butterfly_clock_anzhiyu_injector_config();
  }
  </script><script src="https://widget.qweather.net/simple/static/js/he-simple-common.js?v=2.0"></script><script data-pjax src="https://cdn.cbd.int/hexo-butterfly-clock-anzhiyu/lib/clock.min.js"></script><script data-pjax>
  function butterfly_swiper_injector_config(){
    var parent_div_git = document.getElementById('recent-posts');
    var item_html = '<div class="recent-post-item" style="height: auto;width: 100%"><div class="blog-slider swiper-container-fade swiper-container-horizontal" id="swiper_container"><div class="blog-slider__wrp swiper-wrapper" style="transition-duration: 0ms;"><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/57980/" alt=""><img width="48" height="48" src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/13.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2023-01-06</span><a class="blog-slider__title" href="posts/57980/" alt="">2022年终总结</a><div class="blog-slider__text">憨鸠鸠又一日，柒懵懵又一年</div><a class="blog-slider__button" href="posts/57980/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/59594/" alt=""><img width="48" height="48" src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/14.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-07-30</span><a class="blog-slider__title" href="posts/59594/" alt="">新生入学攻略1.0</a><div class="blog-slider__text">随便写写</div><a class="blog-slider__button" href="posts/59594/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/24342/" alt=""><img width="48" height="48" src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/10.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2020-09-21</span><a class="blog-slider__title" href="posts/24342/" alt="">数据结构笔记（桂电教材版本）</a><div class="blog-slider__text">随便写写</div><a class="blog-slider__button" href="posts/24342/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/41083/" alt=""><img width="48" height="48" src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/12.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2020-12-25</span><a class="blog-slider__title" href="posts/41083/" alt="">2020年终总结</a><div class="blog-slider__text">随便写写</div><a class="blog-slider__button" href="posts/41083/" alt="">详情   </a></div></div><div class="blog-slider__item swiper-slide" style="width: 750px; opacity: 1; transform: translate3d(0px, 0px, 0px); transition-duration: 0ms;"><a class="blog-slider__img" href="posts/8569/" alt=""><img width="48" height="48" src="https://aimerl0-1303178350.cos.ap-guangzhou.myqcloud.com/img/10.jpg" alt="" onerror="this.src=https://unpkg.zhimg.com/akilar-candyassets/image/loading.gif; this.onerror = null;"/></a><div class="blog-slider__content"><span class="blog-slider__code">2021-12-28</span><a class="blog-slider__title" href="posts/8569/" alt="">2021年终总结</a><div class="blog-slider__text">随便写写</div><a class="blog-slider__button" href="posts/8569/" alt="">详情   </a></div></div></div><div class="blog-slider__pagination swiper-pagination-clickable swiper-pagination-bullets"></div></div></div>';
    console.log('已挂载butterfly_swiper')
    parent_div_git.insertAdjacentHTML("afterbegin",item_html)
    }
  var elist = 'undefined'.split(',');
  var cpage = location.pathname;
  var epage = 'all';
  var flag = 0;

  for (var i=0;i<elist.length;i++){
    if (cpage.includes(elist[i])){
      flag++;
    }
  }

  if ((epage ==='all')&&(flag == 0)){
    butterfly_swiper_injector_config();
  }
  else if (epage === cpage){
    butterfly_swiper_injector_config();
  }
  </script><script defer src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper.min.js"></script><script defer data-pjax src="https://npm.elemecdn.com/hexo-butterfly-swiper/lib/swiper_init.js"></script><!-- hexo injector body_end end --></body></html>